<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>不忘初心 </title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.30.2" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    <link href='https://daonao.github.io/chuxin/dist/main.css' rel='stylesheet' type="text/css" />
    
      
    

    
      <link href="https://daonao.github.io/chuxin/tags/index.xml" rel="alternate" type="application/rss+xml" title="不忘初心" />
      <link href="https://daonao.github.io/chuxin/tags/index.xml" rel="feed" type="application/rss+xml" title="不忘初心" />
    

    <meta property="og:title" content="Tags" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://daonao.github.io/chuxin/tags/" />



<meta property="og:updated_time" content="2017-08-04T15:32:49&#43;00:00"/>










<meta itemprop="name" content="Tags">
<meta itemprop="description" content="">

<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Tags"/>
<meta name="twitter:description" content=""/>

  </head>

  <body class="ma0 avenir bg-near-white">

    

  
  
  <header class="cover bg-top" style="background-image: url('https://daonao.github.io/chuxin/images/gohugo-default-sample-hero-image.jpg');">
    <div class="bg-black-60">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://daonao.github.io/chuxin/" class="f3 fw2 hover-white no-underline white-90 dib">
      不忘初心
    </a>
    <div class="flex-l items-center">
      
      








    </div>
  </div>
</nav>

      <div class="tc-l pv4 pv6-l ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 white-90 mb0 lh-title">
          Tags
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
    
  <article class="cf pa3 pa4-m pa4-l">
    <div class="measure-wide-l center f4 lh-copy nested-copy-line-height nested-links nested-img mid-gray">
      
    </div>
  </article>
  <div class="mw8 center">
    <section class="ph4">
      
        <h2 class="f1">
          <a href="/chuxin/tags/aes" class="link blue hover-black">
            Tag: aes
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2017-08-04-android-aes-%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/" class="link black dim">
        Android AES 加密、解密
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      AES加密介绍
ASE 加密、解密的关键在于秘钥、只有使用加密时使用的秘钥，才可以解密。
生成秘钥的代码网上一大堆，下面的代码可生成一个秘钥
private SecretKey generateKey(String seed) throws Exception { // 获取秘钥生成器 KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;AES&quot;); // 通过种子初始化 SecureRandom secureRandom = new SecureRandom(); secureRandom.setSeed(seed.getBytes(&quot;UTF-8&quot;)); keyGenerator.init(128, secureRandom); // 生成秘钥并返回 return keyGenerator.generateKey(); }  然后使用秘钥进行加密
private byte[] encrypt(String content, SecretKey secretKey) throws Exception { // 秘钥 byte[] enCodeFormat = secretKey.getEncoded(); // 创建AES秘钥 SecretKeySpec key = new SecretKeySpec(enCodeFormat, &quot;AES&quot;); // 创建密码器 Cipher cipher = Cipher.getInstance(&quot;AES&quot;); // 初始化加密器 cipher.init(Cipher.ENCRYPT_MODE, key); // 加密 return cipher.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/android" class="link blue hover-black">
            Tag: android
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2017-08-04-android-aes-%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/" class="link black dim">
        Android AES 加密、解密
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      AES加密介绍
ASE 加密、解密的关键在于秘钥、只有使用加密时使用的秘钥，才可以解密。
生成秘钥的代码网上一大堆，下面的代码可生成一个秘钥
private SecretKey generateKey(String seed) throws Exception { // 获取秘钥生成器 KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;AES&quot;); // 通过种子初始化 SecureRandom secureRandom = new SecureRandom(); secureRandom.setSeed(seed.getBytes(&quot;UTF-8&quot;)); keyGenerator.init(128, secureRandom); // 生成秘钥并返回 return keyGenerator.generateKey(); }  然后使用秘钥进行加密
private byte[] encrypt(String content, SecretKey secretKey) throws Exception { // 秘钥 byte[] enCodeFormat = secretKey.getEncoded(); // 创建AES秘钥 SecretKeySpec key = new SecretKeySpec(enCodeFormat, &quot;AES&quot;); // 创建密码器 Cipher cipher = Cipher.getInstance(&quot;AES&quot;); // 初始化加密器 cipher.init(Cipher.ENCRYPT_MODE, key); // 加密 return cipher.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2017-03-16-android-%E8%93%9D%E7%89%99%E9%80%9A%E4%BF%A1androidbluetoothmanager/" class="link black dim">
        Android蓝牙通信——AndroidBluetoothManager
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN

To get a Git project into your build:
Step 1. Add the JitPack repository to your build file
Add it in your root build.gradle at the end of repositories:
allprojects { repositories { ... maven { url 'https://jitpack.io' } } }  Step 2. Add the dependency
dependencies { compile 'com.github.kongqw:AndroidBluetoothManager:1.0.0' }  AndroidBluetoothManager
效果图 PNG
GIF
基础功能 添加权限 &lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot; /&gt; &lt;uses-permission android:name=&quot;android.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2017-03-10-android%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%B7%E8%BE%BE%E6%89%AB%E6%8F%8F%E6%8E%A7%E4%BB%B6/" class="link black dim">
        Android自定义雷达扫描控件
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
Android 雷达扫描控件 
To get a Git project into your build:
Step 1. Add the JitPack repository to your build file
Add it in your root build.gradle at the end of repositories:
allprojects { repositories { ... maven { url 'https://jitpack.io' } } }  Step 2. Add the dependency
dependencies { compile 'com.github.kongqw:AndroidRadarScanView:1.0.1' }  源码：AndroidRadarScanView
效果图 XML &lt;com.kongqw.radarscanviewlibrary.RadarScanView android:id=&quot;@+id/radarScanView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt;  初始化 radarScanView = (RadarScanView) findViewById(R.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-09-01-android%E8%87%AA%E5%AE%9A%E4%B9%89%E6%91%87%E6%9D%86/" class="link black dim">
        Android自定义摇杆
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
效果图 源码 KqwRockerDemo
喜欢就给个star，谢谢！
功能  支持自适应大小 支持2个方向、4个方向、8个方向的摇动监听 支持摇动角度获取 可选回调模式 支持可摇动区域自定义 支持摇杆自定义 支持设置图片、色值、Shape图形  使用 &lt;kong.qingwei.rockerlibrary.RockerView android:id=&quot;@+id/rockerView_center&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:layout_centerHorizontal=&quot;true&quot; kongqw:areaBackground=&quot;#FF333333&quot; kongqw:rockerBackground=&quot;#FF987654&quot; kongqw:rockerRadius=&quot;15dp&quot; /&gt;  参数    参数 是否必须 描述     areaBackground 可选 可摇动区域的背景   rockerBackground 可选 摇杆的背景   rockerRadius 可选 摇杆半径    设置回调方式 setCallBackMode(CallBackMode mode)  参数
   回调方式 描述     CALL_BACK_MODE_MOVE 有移动就立刻回调   CALL_BACK_MODE_STATE_CHANGE 状态有变化的时候回调    监听摇动角度 返回角度的取值范围：[0°,360°)
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-29-android%E8%BE%93%E5%87%BA%E6%AD%A3%E5%BC%A6%E6%B3%A2%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7-%E5%B7%A6%E5%8F%B3%E5%A3%B0%E9%81%93%E5%AF%B9%E7%A7%B0/" class="link black dim">
        Android输出正弦波音频信号(左右声道对称)
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
需求：左右声道分别输出不同的音频数据，波形要是一个正弦波，左右声道还要对称！ 对硬件不是很了解，说是要通过音波避障。
效果图 之前已经介绍了如何在左右声道输出不同的音频数据。 那么这里主要介绍如何模拟出波形是正弦波的音频数据。
模拟正弦波 /** * 模拟正弦波音频数据 * @param isLeft 左右声道 * @return 音频数据 */ private short[] initData(boolean isLeft) { double phase = 0.0; int amp = 10000; short[] data = new short[bufferSize]; double phaseIncrement = (2 * Math.PI * mFrequency) / mSampleRateInHz; for (int i = 0; i &lt; bufferSize; i++) { if (isLeft) { data[i] = (short) (amp * Math.sin(phase)); } else { data[i] = (short) (-amp * Math.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-26-android%E5%B7%A6%E5%8F%B3%E5%A3%B0%E9%81%93%E7%9A%84%E6%8E%A7%E5%88%B6/" class="link black dim">
        Android左右声道的控制
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
效果图 源码 AndroidSoundManagerDemo
我这里主要是用到了AudioTrack实现的左右声道的控制，手机一般都只有两个声道，即左声道和右声道，我们在输出的时候可以选择单声道，也可以选择双声道（立体声）。
查看了AudioTrack的API，提供了play()、pause()、stop()、write()等一系列的方法。 通过write()方法，可以实现将音频数据发送出去（播放出来）。
AudioTrack对象的构造 有三个构造方法
AudioTrack (int streamType, int sampleRateInHz, int channelConfig, int audioFormat, int bufferSizeInBytes, int mode) AudioTrack (int streamType, int sampleRateInHz, int channelConfig, int audioFormat, int bufferSizeInBytes, int mode, int sessionId) AudioTrack (AudioAttributes attributes, AudioFormat format, int bufferSizeInBytes, int mode, int sessionId)  主要参数有如下几个
 streamType：以什么形式播放
 STREAM_VOICE_CALL STREAM_SYSTEM STREAM_RING STREAM_MUSIC STREAM_ALARM STREAM_NOTIFICATION  sampleRateInHz：采样率
 channelConfig：声道
 AudioFormat.CHANNEL_OUT_MONO：输出单声道音频数据 AudioFormat.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-02-android%E8%93%9D%E7%89%99%E9%80%9A%E4%BF%A1/" class="link black dim">
        Android蓝牙通信
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
Android蓝牙通信 效果图  两台真机设备
 源码 GitHub
 关于蓝牙的开关控制，设置设备可见、搜索附近的蓝牙设备，已经封装到了 BluetoothManager 类
 关于设备的连接、通信。已经封装到了 BluetoothService 类
  注：下面的全部内容，主要是思路，具体的可以参考上面的源码，如果对你有帮助记得给个赞哦。
权限 &lt;!-- 蓝牙的权限 --&gt; &lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot; /&gt;  蓝牙的打开与关闭 开启蓝牙 mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); /** * 开启蓝牙 */ public void openBluetooth() { try { mBluetoothAdapter.enable(); } catch (Exception e) { e.printStackTrace(); } }  关闭蓝牙 mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); /** * 关闭蓝牙 */ public void closeBluetooth() { try { mBluetoothAdapter.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/cifs" class="link blue hover-black">
            Tag: cifs
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/huzhenghui/docker/docker-run-a-single-php-script-from-windows-share-folder/" class="link black dim">
        在 Docker 中运行来自 Windows 共享文件夹的 PHP 脚本
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      CSDN博客
微博文章
微博讨论
在 Docker 中运行 PHP 程序的一种方式是在Dockerfile中使用COPY命令复制源代码到Docker容器中，如果是在本机中，也可以把本地PHP项目文件夹加载到Docker容器中。如果是虚拟机，例如Docker for Windows在Hyper-V中安装的虚拟机，Docker客户端会自动创建共享文件夹到虚拟机中，而对于使用docker-machine命令创建的虚拟机，Docker客户端就不自动管理了，如果是固定位置运行的程序，可以手工设置共享文件夹，如果是临时运行的话，手工设置共享文件夹未免有些繁琐，此时可以借助PowerShell脚本完成共享操作。
假设电脑上的docker-machine中包含一台docker主机且运行正常，不限于本机、本机中的虚拟机或者其他位置，只要在局域网中能相互访问即可。
使用管理员角色启动PowerShell。
下载示例代码。
git clone https://github.com/huzhenghui/Docker-run-a-single-PHP-script-from-Windows-share-folder  进入项目目录。
cd Docker-run-a-single-PHP-script-from-Windows-share-folder  更新子模块。
git submodule update --init  运行自动共享脚本。
share-windows-folder-to-docker/share-windows-folder-to-docker.ps1 -workingDir ./src -volumeName Docker-run-a-single-PHP-script-from-Windows-share-folder  该脚本将自动把示例项目中的./src文件夹共享到Docker主机中的卷。
测试共享。
docker run --rm -v Docker-run-a-single-PHP-script-from-Windows-share-folder:/share alpine ls /share  将看到列出文件夹中的文件
phpinfo.php  运行PHP程序
docker run -it --rm -v Docker-run-a-single-PHP-script-from-Windows-share-folder:/src -w /src php:latest php phpinfo.php  可以看到输出运行结果。
这种方式把Docker容器作为PHP的运行时环境，而不是单独的PHP程序，因此只需要一个PHP镜像，不需要单独为每个程序创建镜像。例如PHP程序消耗较大的计算资源，而又希望程序和输入、输出的文件都保存在Windows设备时，就适合使用这种方式。
使用的方式也很简单，直接在项目中引入即可。
git submodule add https://github.com/huzhenghui/share-windows-folder-to-docker  
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/composer" class="link blue hover-black">
            Tag: composer
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/huzhenghui/docker/docker-decoupling-operation-tool-and-runtime-tool/" class="link black dim">
        借助Docker解耦合运维工具和运行时工具
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      CSDN博客
微博文章
微博
在部署的时候，经常会遇到这样的情况，运维工具和运行时工具互相干扰，借助Docker可以很方便的解决这个问题，下面以部署Zend Expressive Skeleton为例说明（这个例子中没有运维工具和运行时工具互相干扰的问题，仅用于演示）。
准备 本例假设在Windows操作系统中，Linux的情况可能会更简单些。假设使用docker-machine命令可以访问到一台Docker主机。
公共部分 为了不纠缠具体的技术细节，本例已经把和具体项目无关的公共部分独立为开源项目。
进入工作目录。
下载使用Docker运行nginx+PHP-fpm路由模式的代码
git clone https://github.com/huzhenghui/Docker-run-nginx-PHP-fpm-web-server-router-from-Windows-share-folder zend-expressive-skeleton  进入项目文件夹
cd zend-expressive-skeleton  更新子模块代码
git submodule update --init  由于Docker主机上的卷需要唯一名称，本文使用一个环境变量。
$env:VOLUME_NAME=&quot;zend-expressive-skeleton&quot;  以管理员权限启动PowerShell，运行把Windows文件夹共享到Docker主机的脚本，此处要求docker-machine命令能访问到一台运行中的Docker主机，更多选项请参考其中的源代码。
.\share-windows-folder-to-docker\share-windows-folder-to-docker.ps1 -workingDir . -volumeName ${env:VOLUME_NAME}  测试卷的加载情况。
docker run --rm -v ${env:VOLUME_NAME}:/nginx-PHP-fpm-web-server-router alpine ls /nginx-PHP-fpm-web-server-router  显示文件夹的内容即代表共享成功。
LICENSE docker-compose.yml nginx php share-windows-folder-to-docker  交互安装模式 在公共部分的基础上，可以交互安装。
先删除原有位置的代码。
docker run -it --rm -v ${env:VOLUME_NAME}:/nginx-PHP-fpm-web-server-router --entrypoint /bin/sh alpine -c &quot;rm -rf /nginx-PHP-fpm-web-server-router/php&quot;  然后安装。
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/docker" class="link blue hover-black">
            Tag: docker
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/huzhenghui/docker/docker-decoupling-operation-tool-and-runtime-tool/" class="link black dim">
        借助Docker解耦合运维工具和运行时工具
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      CSDN博客
微博文章
微博
在部署的时候，经常会遇到这样的情况，运维工具和运行时工具互相干扰，借助Docker可以很方便的解决这个问题，下面以部署Zend Expressive Skeleton为例说明（这个例子中没有运维工具和运行时工具互相干扰的问题，仅用于演示）。
准备 本例假设在Windows操作系统中，Linux的情况可能会更简单些。假设使用docker-machine命令可以访问到一台Docker主机。
公共部分 为了不纠缠具体的技术细节，本例已经把和具体项目无关的公共部分独立为开源项目。
进入工作目录。
下载使用Docker运行nginx+PHP-fpm路由模式的代码
git clone https://github.com/huzhenghui/Docker-run-nginx-PHP-fpm-web-server-router-from-Windows-share-folder zend-expressive-skeleton  进入项目文件夹
cd zend-expressive-skeleton  更新子模块代码
git submodule update --init  由于Docker主机上的卷需要唯一名称，本文使用一个环境变量。
$env:VOLUME_NAME=&quot;zend-expressive-skeleton&quot;  以管理员权限启动PowerShell，运行把Windows文件夹共享到Docker主机的脚本，此处要求docker-machine命令能访问到一台运行中的Docker主机，更多选项请参考其中的源代码。
.\share-windows-folder-to-docker\share-windows-folder-to-docker.ps1 -workingDir . -volumeName ${env:VOLUME_NAME}  测试卷的加载情况。
docker run --rm -v ${env:VOLUME_NAME}:/nginx-PHP-fpm-web-server-router alpine ls /nginx-PHP-fpm-web-server-router  显示文件夹的内容即代表共享成功。
LICENSE docker-compose.yml nginx php share-windows-folder-to-docker  交互安装模式 在公共部分的基础上，可以交互安装。
先删除原有位置的代码。
docker run -it --rm -v ${env:VOLUME_NAME}:/nginx-PHP-fpm-web-server-router --entrypoint /bin/sh alpine -c &quot;rm -rf /nginx-PHP-fpm-web-server-router/php&quot;  然后安装。
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/huzhenghui/docker/docker-run-nginx-php-fpm-web-server-router-from-windows-share-folder/" class="link black dim">
        （开包即用，不用看代码！）在 Docker 中用 nginx 和 PHP-fpm 运行来自 Windows 共享文件夹的路由模式网站
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      CSDN博客
微博文章
微博
准备  PowerShell git docker 使用docker-machine命令可以找到一台可用的Docker主机  开包即用，不用看代码！ 初始化 进入一个文件夹。
下载已经写好的开源项目
git clone https://github.com/huzhenghui/Docker-run-nginx-PHP-fpm-web-server-router-from-Windows-share-folder  进入开源项目文件夹
cd Docker-run-nginx-PHP-fpm-web-server-router-from-Windows-share-folder  更新子模块代码
git submodule update --init  使用管理员权限的PowerShell运行共享文件夹到Docker的脚本。
.\share-windows-folder-to-docker\share-windows-folder-to-docker.ps1 -workingDir . -volumeName nginx-PHP-fpm-web-server-router  查看文件夹是否共享成功
docker run --rm -v nginx-PHP-fpm-web-server-router:/share alpine ls /share  如果成功将看到开源项目的如下文件列表
LICENSE docker-compose.yml nginx php share-windows-folder-to-docker  使用PHP内建的Web Server的路由方式 启动PHP内建web server
docker run -it --rm -v nginx-PHP-fpm-web-server-router:/nginx-PHP-fpm-web-server-router -p 80:80 php -S 0.0.0.0:80 -t /nginx-PHP-fpm-web-server-router/php/public index.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/huzhenghui/docker/docker-run-nginx-php-fpm-web-server-from-windows-share-folder/" class="link black dim">
        （开包即用，不用看代码！）在 Docker 中用 nginx 和 PHP-fpm 运行来自 Windows 共享文件夹的网站
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      CSDN博客
微博文章
微博
准备  PowerShell git docker 使用docker-machine命令可以找到一台可用的Docker主机  开包即用，不用看代码！ 初始化 进入一个文件夹。
下载已经写好的开源项目
git clone https://github.com/huzhenghui/Docker-run-nginx-PHP-fpm-web-server-from-Windows-share-folder  进入开源项目文件夹
cd Docker-run-nginx-PHP-fpm-web-server-from-Windows-share-folder  更新子模块代码
git submodule update --init  使用管理员权限的PowerShell运行共享文件夹到Docker的脚本。
.\share-windows-folder-to-docker\share-windows-folder-to-docker.ps1 -workingDir . -volumeName nginx-PHP-fpm-web-server  查看文件夹是否共享成功
docker run --rm -v nginx-PHP-fpm-web-server:/share alpine ls /share  如果成功将看到开源项目的如下文件列表
LICENSE docker-compose.yml nginx php share-windows-folder-to-docker  使用PHP内建的Web Server 启动PHP内建web server
docker run -it --rm -v nginx-PHP-fpm-web-server:/nginx-PHP-fpm-web-server -p 80:80 php -S 0.0.0.0:80 -t /nginx-PHP-fpm-web-server/php/public  正确启动将看到如下信息
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/huzhenghui/php/test-php-cve-2018-5711-by-docker/" class="link black dim">
        使用 Docker 测试 PHP CVE-2018-5711 漏洞
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      CSDN博客
微博文章
微博
漏洞说明 编号为PHP CVE-2018-5711的漏洞能让运行PHP的服务器瞬间宕机，原理是gd库在遇到特定非法格式的gif图片时会耗尽CPU，影响范围如下：
 PHP 5 &lt; 5.6.33 PHP 7.0 &lt; 7.0.27 PHP 7.1 &lt; 7.1.13 PHP 7.2 &lt; 7.2.1  其中列出的都是该系列的最高版本，也就是说几乎所有使用gd库的PHP都需要为此更新到最高版本。
下面介绍这个漏洞在Docker中验证的方法，需要强调，这里提供了非法格式的git图片文件，如果上传到没有更新的服务器，不排除服务器宕机的可能，造成经济损失将违反相关法律。
PHP 7.2.0版本中的漏洞 下载代码
git clone https://github.com/huzhenghui/Test-7-2-0-PHP-CVE-2018-5711.git  进入项目文件夹
cd Test-7-2-0-PHP-CVE-2018-5711  构建Docker镜像
docker build -t test-7-2-0-php-cve-2018-5711 .  构建成功后查看PHP版本
docker run --rm test-7-2-0-php-cve-2018-5711 -v  可以看到
PHP 7.2.0 (cli) (built: Jan 4 2018 01:20:58) ( NTS ) Copyright (c) 1997-2017 The PHP Group Zend Engine v3.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/huzhenghui/docker/docker-run-a-single-php-script-from-windows-share-folder/" class="link black dim">
        在 Docker 中运行来自 Windows 共享文件夹的 PHP 脚本
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      CSDN博客
微博文章
微博讨论
在 Docker 中运行 PHP 程序的一种方式是在Dockerfile中使用COPY命令复制源代码到Docker容器中，如果是在本机中，也可以把本地PHP项目文件夹加载到Docker容器中。如果是虚拟机，例如Docker for Windows在Hyper-V中安装的虚拟机，Docker客户端会自动创建共享文件夹到虚拟机中，而对于使用docker-machine命令创建的虚拟机，Docker客户端就不自动管理了，如果是固定位置运行的程序，可以手工设置共享文件夹，如果是临时运行的话，手工设置共享文件夹未免有些繁琐，此时可以借助PowerShell脚本完成共享操作。
假设电脑上的docker-machine中包含一台docker主机且运行正常，不限于本机、本机中的虚拟机或者其他位置，只要在局域网中能相互访问即可。
使用管理员角色启动PowerShell。
下载示例代码。
git clone https://github.com/huzhenghui/Docker-run-a-single-PHP-script-from-Windows-share-folder  进入项目目录。
cd Docker-run-a-single-PHP-script-from-Windows-share-folder  更新子模块。
git submodule update --init  运行自动共享脚本。
share-windows-folder-to-docker/share-windows-folder-to-docker.ps1 -workingDir ./src -volumeName Docker-run-a-single-PHP-script-from-Windows-share-folder  该脚本将自动把示例项目中的./src文件夹共享到Docker主机中的卷。
测试共享。
docker run --rm -v Docker-run-a-single-PHP-script-from-Windows-share-folder:/share alpine ls /share  将看到列出文件夹中的文件
phpinfo.php  运行PHP程序
docker run -it --rm -v Docker-run-a-single-PHP-script-from-Windows-share-folder:/src -w /src php:latest php phpinfo.php  可以看到输出运行结果。
这种方式把Docker容器作为PHP的运行时环境，而不是单独的PHP程序，因此只需要一个PHP镜像，不需要单独为每个程序创建镜像。例如PHP程序消耗较大的计算资源，而又希望程序和输入、输出的文件都保存在Windows设备时，就适合使用这种方式。
使用的方式也很简单，直接在项目中引入即可。
git submodule add https://github.com/huzhenghui/share-windows-folder-to-docker  
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/elk" class="link blue hover-black">
            Tag: elk
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/thinkgamer/elk/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E4%B9%8B%E6%8C%87%E6%95%B0%E5%B9%B3%E6%BB%91%E5%88%A9%E7%94%A8elasticsearch%E6%9D%A5%E5%AE%9E%E7%8E%B0/" class="link black dim">
        异常检测之指数平滑（利用elasticsearch来实现）
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      指数平滑法是一种特殊的加权平均法，加权的特点是对离预测值较近的历史数据给予较大的权数，对离预测期较远的历史数据给予较小的权数，权数由近到远按指数规律递减，所以，这种预测方法被称为指数平滑法。它可分为一次指数平滑法、二次指数平滑法及更高次指数平滑法。 
关于指数平滑的得相关资料：  ES API接口： &gt; https://github.com/IBBD/IBBD.github.io/blob/master/elk/aggregations-pipeline.md https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-movavg-aggregation.html
 理论概念 &gt; http://blog.sina.com.cn/s/blog_4b9acb5201016nkd.html
  ES移动平均聚合：Moving Average的四种模型 simple 就是使用窗口内的值的和除于窗口值，通常窗口值越大，最后的结果越平滑: (a1 + a2 + &hellip; + an) / n
curl -XPOST 'localhost:9200/_search?pretty' -H 'Content-Type: application/json' -d' { &quot;size&quot;: 0, &quot;aggs&quot;: { &quot;my_date_histo&quot;:{ &quot;date_histogram&quot;:{ &quot;field&quot;:&quot;date&quot;, &quot;interval&quot;:&quot;1M&quot; }, &quot;aggs&quot;:{ &quot;the_sum&quot;:{ &quot;sum&quot;:{ &quot;field&quot;: &quot;price&quot; } }, &quot;the_movavg&quot;:{ &quot;moving_avg&quot;:{ &quot;buckets_path&quot;: &quot;the_sum&quot;, &quot;window&quot; : 30, &quot;model&quot; : &quot;simple&quot; } } } } } } '  线性模型：Linear 对窗口内的值先做线性变换处理，再求平均：(a1 * 1 + a2 * 2 + &hellip; + an * n) / (1 + 2 + &hellip; + n)
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/thinkgamer/elk/elasticsearch-dsl%E9%83%A8%E5%88%86%E9%9B%86%E5%90%88/" class="link black dim">
        Elasticsearch-DSL部分集合
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      ELK是日志收集分析神器，在这篇文章中将会介绍一些ES的常用命令。
点击阅读：ELK Stack 从入门到放弃 
DSL中遇到的错误及解决办法 分片限制错误 Trying to query 2632 shards, which is over the limit of 1000. This limit exists because querying many shards at the same time can make the job of the coordinating node very CPU and/or memory intensive. It is usually a better idea to have a smaller number of larger shards. Update [action.search.shard_count.limit] to a greater value if you really want to query that many shards at the same time.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/es" class="link blue hover-black">
            Tag: es
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/thinkgamer/elk/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E4%B9%8B%E6%8C%87%E6%95%B0%E5%B9%B3%E6%BB%91%E5%88%A9%E7%94%A8elasticsearch%E6%9D%A5%E5%AE%9E%E7%8E%B0/" class="link black dim">
        异常检测之指数平滑（利用elasticsearch来实现）
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      指数平滑法是一种特殊的加权平均法，加权的特点是对离预测值较近的历史数据给予较大的权数，对离预测期较远的历史数据给予较小的权数，权数由近到远按指数规律递减，所以，这种预测方法被称为指数平滑法。它可分为一次指数平滑法、二次指数平滑法及更高次指数平滑法。 
关于指数平滑的得相关资料：  ES API接口： &gt; https://github.com/IBBD/IBBD.github.io/blob/master/elk/aggregations-pipeline.md https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-movavg-aggregation.html
 理论概念 &gt; http://blog.sina.com.cn/s/blog_4b9acb5201016nkd.html
  ES移动平均聚合：Moving Average的四种模型 simple 就是使用窗口内的值的和除于窗口值，通常窗口值越大，最后的结果越平滑: (a1 + a2 + &hellip; + an) / n
curl -XPOST 'localhost:9200/_search?pretty' -H 'Content-Type: application/json' -d' { &quot;size&quot;: 0, &quot;aggs&quot;: { &quot;my_date_histo&quot;:{ &quot;date_histogram&quot;:{ &quot;field&quot;:&quot;date&quot;, &quot;interval&quot;:&quot;1M&quot; }, &quot;aggs&quot;:{ &quot;the_sum&quot;:{ &quot;sum&quot;:{ &quot;field&quot;: &quot;price&quot; } }, &quot;the_movavg&quot;:{ &quot;moving_avg&quot;:{ &quot;buckets_path&quot;: &quot;the_sum&quot;, &quot;window&quot; : 30, &quot;model&quot; : &quot;simple&quot; } } } } } } '  线性模型：Linear 对窗口内的值先做线性变换处理，再求平均：(a1 * 1 + a2 * 2 + &hellip; + an * n) / (1 + 2 + &hellip; + n)
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/thinkgamer/elk/elasticsearch-dsl%E9%83%A8%E5%88%86%E9%9B%86%E5%90%88/" class="link black dim">
        Elasticsearch-DSL部分集合
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      ELK是日志收集分析神器，在这篇文章中将会介绍一些ES的常用命令。
点击阅读：ELK Stack 从入门到放弃 
DSL中遇到的错误及解决办法 分片限制错误 Trying to query 2632 shards, which is over the limit of 1000. This limit exists because querying many shards at the same time can make the job of the coordinating node very CPU and/or memory intensive. It is usually a better idea to have a smaller number of larger shards. Update [action.search.shard_count.limit] to a greater value if you really want to query that many shards at the same time.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/gd" class="link blue hover-black">
            Tag: gd
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/huzhenghui/php/test-php-cve-2018-5711-by-docker/" class="link black dim">
        使用 Docker 测试 PHP CVE-2018-5711 漏洞
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      CSDN博客
微博文章
微博
漏洞说明 编号为PHP CVE-2018-5711的漏洞能让运行PHP的服务器瞬间宕机，原理是gd库在遇到特定非法格式的gif图片时会耗尽CPU，影响范围如下：
 PHP 5 &lt; 5.6.33 PHP 7.0 &lt; 7.0.27 PHP 7.1 &lt; 7.1.13 PHP 7.2 &lt; 7.2.1  其中列出的都是该系列的最高版本，也就是说几乎所有使用gd库的PHP都需要为此更新到最高版本。
下面介绍这个漏洞在Docker中验证的方法，需要强调，这里提供了非法格式的git图片文件，如果上传到没有更新的服务器，不排除服务器宕机的可能，造成经济损失将违反相关法律。
PHP 7.2.0版本中的漏洞 下载代码
git clone https://github.com/huzhenghui/Test-7-2-0-PHP-CVE-2018-5711.git  进入项目文件夹
cd Test-7-2-0-PHP-CVE-2018-5711  构建Docker镜像
docker build -t test-7-2-0-php-cve-2018-5711 .  构建成功后查看PHP版本
docker run --rm test-7-2-0-php-cve-2018-5711 -v  可以看到
PHP 7.2.0 (cli) (built: Jan 4 2018 01:20:58) ( NTS ) Copyright (c) 1997-2017 The PHP Group Zend Engine v3.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/git" class="link blue hover-black">
            Tag: git
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/huzhenghui/docker/docker-decoupling-operation-tool-and-runtime-tool/" class="link black dim">
        借助Docker解耦合运维工具和运行时工具
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      CSDN博客
微博文章
微博
在部署的时候，经常会遇到这样的情况，运维工具和运行时工具互相干扰，借助Docker可以很方便的解决这个问题，下面以部署Zend Expressive Skeleton为例说明（这个例子中没有运维工具和运行时工具互相干扰的问题，仅用于演示）。
准备 本例假设在Windows操作系统中，Linux的情况可能会更简单些。假设使用docker-machine命令可以访问到一台Docker主机。
公共部分 为了不纠缠具体的技术细节，本例已经把和具体项目无关的公共部分独立为开源项目。
进入工作目录。
下载使用Docker运行nginx+PHP-fpm路由模式的代码
git clone https://github.com/huzhenghui/Docker-run-nginx-PHP-fpm-web-server-router-from-Windows-share-folder zend-expressive-skeleton  进入项目文件夹
cd zend-expressive-skeleton  更新子模块代码
git submodule update --init  由于Docker主机上的卷需要唯一名称，本文使用一个环境变量。
$env:VOLUME_NAME=&quot;zend-expressive-skeleton&quot;  以管理员权限启动PowerShell，运行把Windows文件夹共享到Docker主机的脚本，此处要求docker-machine命令能访问到一台运行中的Docker主机，更多选项请参考其中的源代码。
.\share-windows-folder-to-docker\share-windows-folder-to-docker.ps1 -workingDir . -volumeName ${env:VOLUME_NAME}  测试卷的加载情况。
docker run --rm -v ${env:VOLUME_NAME}:/nginx-PHP-fpm-web-server-router alpine ls /nginx-PHP-fpm-web-server-router  显示文件夹的内容即代表共享成功。
LICENSE docker-compose.yml nginx php share-windows-folder-to-docker  交互安装模式 在公共部分的基础上，可以交互安装。
先删除原有位置的代码。
docker run -it --rm -v ${env:VOLUME_NAME}:/nginx-PHP-fpm-web-server-router --entrypoint /bin/sh alpine -c &quot;rm -rf /nginx-PHP-fpm-web-server-router/php&quot;  然后安装。
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/huzhenghui/docker/docker-run-nginx-php-fpm-web-server-router-from-windows-share-folder/" class="link black dim">
        （开包即用，不用看代码！）在 Docker 中用 nginx 和 PHP-fpm 运行来自 Windows 共享文件夹的路由模式网站
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      CSDN博客
微博文章
微博
准备  PowerShell git docker 使用docker-machine命令可以找到一台可用的Docker主机  开包即用，不用看代码！ 初始化 进入一个文件夹。
下载已经写好的开源项目
git clone https://github.com/huzhenghui/Docker-run-nginx-PHP-fpm-web-server-router-from-Windows-share-folder  进入开源项目文件夹
cd Docker-run-nginx-PHP-fpm-web-server-router-from-Windows-share-folder  更新子模块代码
git submodule update --init  使用管理员权限的PowerShell运行共享文件夹到Docker的脚本。
.\share-windows-folder-to-docker\share-windows-folder-to-docker.ps1 -workingDir . -volumeName nginx-PHP-fpm-web-server-router  查看文件夹是否共享成功
docker run --rm -v nginx-PHP-fpm-web-server-router:/share alpine ls /share  如果成功将看到开源项目的如下文件列表
LICENSE docker-compose.yml nginx php share-windows-folder-to-docker  使用PHP内建的Web Server的路由方式 启动PHP内建web server
docker run -it --rm -v nginx-PHP-fpm-web-server-router:/nginx-PHP-fpm-web-server-router -p 80:80 php -S 0.0.0.0:80 -t /nginx-PHP-fpm-web-server-router/php/public index.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/huzhenghui/docker/docker-run-nginx-php-fpm-web-server-from-windows-share-folder/" class="link black dim">
        （开包即用，不用看代码！）在 Docker 中用 nginx 和 PHP-fpm 运行来自 Windows 共享文件夹的网站
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      CSDN博客
微博文章
微博
准备  PowerShell git docker 使用docker-machine命令可以找到一台可用的Docker主机  开包即用，不用看代码！ 初始化 进入一个文件夹。
下载已经写好的开源项目
git clone https://github.com/huzhenghui/Docker-run-nginx-PHP-fpm-web-server-from-Windows-share-folder  进入开源项目文件夹
cd Docker-run-nginx-PHP-fpm-web-server-from-Windows-share-folder  更新子模块代码
git submodule update --init  使用管理员权限的PowerShell运行共享文件夹到Docker的脚本。
.\share-windows-folder-to-docker\share-windows-folder-to-docker.ps1 -workingDir . -volumeName nginx-PHP-fpm-web-server  查看文件夹是否共享成功
docker run --rm -v nginx-PHP-fpm-web-server:/share alpine ls /share  如果成功将看到开源项目的如下文件列表
LICENSE docker-compose.yml nginx php share-windows-folder-to-docker  使用PHP内建的Web Server 启动PHP内建web server
docker run -it --rm -v nginx-PHP-fpm-web-server:/nginx-PHP-fpm-web-server -p 80:80 php -S 0.0.0.0:80 -t /nginx-PHP-fpm-web-server/php/public  正确启动将看到如下信息
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/gradle" class="link blue hover-black">
            Tag: gradle
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2017-03-02-gradle%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="link black dim">
        Gradle常用技巧
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
Gradle http://google.github.io/android-gradle-dsl/current/index.html
https://docs.gradle.org/current/userguide/java_plugin.html
打包多个版本 开发过程中我们经常需要打包多个版本的apk，最为常见的，一个是release版本，一个是debug版本，他们可能使用的api也有所区别，手动改起来总是很麻烦。 我们可以通过Gradle，配置多个版本，他们有各自的参数来区分不同的版本。如下，在 app/build.gradle 系统默认会给我生成release版本，我们可以手动自己添加一个版本，我这里命名为debug，分别添加了三种类型的参数。
apply plugin: 'com.android.application' android { …… buildTypes { release { …… buildConfigField(&quot;boolean&quot;, &quot;isDebug&quot;, &quot;false&quot;) } debug { // 添加了boolean类型的参数 buildConfigField(&quot;boolean&quot;, &quot;isDebug&quot;, &quot;true&quot;) // 添加了String类型的参数 buildConfigField(&quot;String&quot;, &quot;coder&quot;, &quot;\&quot;kongqw\&quot;&quot;) // 添加了int类型的参数 buildConfigField(&quot;int&quot;, &quot;age&quot;, &quot;26&quot;) } } } …… dependencies { …… }  添加完成后Rebuild，会在 BuildConfig 下看到我们添加的参数
因为是静态变量，取值时直接用类名点变量名即可
上述属于在Java代码中添加字段，同样的，Gradle也支持添加xml属性，类似这样
apply plugin: 'com.android.application' android { …… defaultConfig { …… } buildTypes { release { …… } debug { …… resValue(&quot;bool&quot;, &quot;is_debug&quot;, &quot;true&quot;) resValue(&quot;string&quot;, &quot;coder&quot;, &quot;\&quot;kongqw\&quot;&quot;) resValue(&quot;integer&quot;, &quot;age&quot;, &quot;26&quot;) } } } dependencies { …… }  添加完以后Rebuild，会在generated.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/help" class="link blue hover-black">
            Tag: help
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/huzhenghui/help/markdown-tables-sample/" class="link black dim">
        Markdown Tables Sample 表格示例
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
       Markdown Tables Sample 表格示例  Name | Age --------|------ Bob | 27 Alice | 23     Name Age     Bob 27   Alice 23    
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/huzhenghui/help/front-matter-sample/" class="link black dim">
        Front Matter Sample 格式示例
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Front Matter Sample 格式示例 目前使用的 Hugo 支持 Markdown Front Matter 语法 https://jekyllrb.com/docs/frontmatter/ 主要涉及 title、date、tags、categories四个变量 也就是 .md 文件的开头需要包含如下内容
--- title: Post Format Sample 文章格式示例 date: 2018-01-30 17:54:55 tags: [help] categories: help ---  需要注意 Hugo 按照 .md 文件中的 date 变量排序，如果不写或者格式错误，那么就会被排在最后了。 可以在 GitHub 中预览 Markdown Front Matter 语法是否正确，例如上例预览效果为
   title date tags categories     Post Format Sample 文章格式示例 2018-01-30 09:54:55 -0800 help help    预览中在 date 变量看到时区，也就是 -0800 或者类似的字样代表正确。
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/hexo" class="link blue hover-black">
            Tag: hexo
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/thinkgamer/%E9%9A%8F%E6%89%8B%E8%AE%B0/hexo-yilia%E5%8A%A0%E5%85%A5%E7%9B%B8%E5%86%8C%E5%8A%9F%E8%83%BD/" class="link black dim">
        Hexo-Yilia加入相册功能
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      参考：点击查看
但是其中有一些小问题，自己便重新整理了一下（本文适用于使用github存放照片）
 主页新建相册链接 主题_config.json文件的menu 中加入 相册和对应的链接
themes/yilia/_config.json menu: 主页: / ... ... 相册: /photos  新建目录并拷贝相应文件 使用的是litten 大神的博客 photos文件夹，对应的路径为： https://github.com/litten/BlogBackup/tree/master/source/photos
自己的项目根目录下的source文件夹下新建photos文件夹，将下载的几个文件放在该文件夹中，或者不用新建，直接将下载的photos文件夹放在source目录下。
文件修改  修改 ins.js 文件的 render()函数 这个函数是用来渲染数据的 修改图片的路径地址.minSrc 小图的路径. src 大图的路径.修改为自己的图片路径(github的路径) 例如我的为： ``` var minSrc = &lsquo;https://raw.githubusercontent.com/Thinkgamer/GitBlog/master/min_photos/' + data.link[i] + &lsquo;.min.jpg&rsquo;; var src = &lsquo;https://raw.githubusercontent.com/Thinkgamer/GitBlog/master/photos/' + data.link[i];  # 生成json 1：下载相应python工具文件 - tools.py - ImageProcess.py 下载地址：https://github.com/Thinkgamer/GitBlog 2：新建photos和min_photos文件夹 在项目根目录下创建，用来存放照片和压缩后的照片  mkdir photos mkdir min_photos
3：py文件和文件夹都放在项目根目录下 4：生成json 执行  python tools.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/im" class="link blue hover-black">
            Tag: im
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-22-%E7%8E%AF%E4%BF%A1%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E5%9C%A8android%E5%B9%B3%E5%8F%B0%E7%9A%84%E9%83%A8%E7%BD%B2/" class="link black dim">
        环信即时通讯在Android平台的部署
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
官网 环信
下载SDK
创建一个工程 如果想要封装性好一点，也可以在工程里再创建一个环信的Library，然后将SDK里的jar和.so，都导入到工程
清单文件 下面是环信Library库里面的清单文件，包含了权限的设置、APPKEY的设置和服务的声明等。
&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;……&quot;&gt; &lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.GET_TASKS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.USE_CREDENTIALS&quot; /&gt; &lt;uses-permission android:name=&quot;com.android.launcher.permission.READ_SETTINGS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.BROADCAST_STICKY&quot; /&gt; &lt;uses-permission android:name=&quot;android.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/linux" class="link blue hover-black">
            Tag: linux
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/huzhenghui/docker/docker-run-a-single-php-script-from-windows-share-folder/" class="link black dim">
        在 Docker 中运行来自 Windows 共享文件夹的 PHP 脚本
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      CSDN博客
微博文章
微博讨论
在 Docker 中运行 PHP 程序的一种方式是在Dockerfile中使用COPY命令复制源代码到Docker容器中，如果是在本机中，也可以把本地PHP项目文件夹加载到Docker容器中。如果是虚拟机，例如Docker for Windows在Hyper-V中安装的虚拟机，Docker客户端会自动创建共享文件夹到虚拟机中，而对于使用docker-machine命令创建的虚拟机，Docker客户端就不自动管理了，如果是固定位置运行的程序，可以手工设置共享文件夹，如果是临时运行的话，手工设置共享文件夹未免有些繁琐，此时可以借助PowerShell脚本完成共享操作。
假设电脑上的docker-machine中包含一台docker主机且运行正常，不限于本机、本机中的虚拟机或者其他位置，只要在局域网中能相互访问即可。
使用管理员角色启动PowerShell。
下载示例代码。
git clone https://github.com/huzhenghui/Docker-run-a-single-PHP-script-from-Windows-share-folder  进入项目目录。
cd Docker-run-a-single-PHP-script-from-Windows-share-folder  更新子模块。
git submodule update --init  运行自动共享脚本。
share-windows-folder-to-docker/share-windows-folder-to-docker.ps1 -workingDir ./src -volumeName Docker-run-a-single-PHP-script-from-Windows-share-folder  该脚本将自动把示例项目中的./src文件夹共享到Docker主机中的卷。
测试共享。
docker run --rm -v Docker-run-a-single-PHP-script-from-Windows-share-folder:/share alpine ls /share  将看到列出文件夹中的文件
phpinfo.php  运行PHP程序
docker run -it --rm -v Docker-run-a-single-PHP-script-from-Windows-share-folder:/src -w /src php:latest php phpinfo.php  可以看到输出运行结果。
这种方式把Docker容器作为PHP的运行时环境，而不是单独的PHP程序，因此只需要一个PHP镜像，不需要单独为每个程序创建镜像。例如PHP程序消耗较大的计算资源，而又希望程序和输入、输出的文件都保存在Windows设备时，就适合使用这种方式。
使用的方式也很简单，直接在项目中引入即可。
git submodule add https://github.com/huzhenghui/share-windows-folder-to-docker  
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/nginx" class="link blue hover-black">
            Tag: nginx
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/huzhenghui/docker/docker-decoupling-operation-tool-and-runtime-tool/" class="link black dim">
        借助Docker解耦合运维工具和运行时工具
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      CSDN博客
微博文章
微博
在部署的时候，经常会遇到这样的情况，运维工具和运行时工具互相干扰，借助Docker可以很方便的解决这个问题，下面以部署Zend Expressive Skeleton为例说明（这个例子中没有运维工具和运行时工具互相干扰的问题，仅用于演示）。
准备 本例假设在Windows操作系统中，Linux的情况可能会更简单些。假设使用docker-machine命令可以访问到一台Docker主机。
公共部分 为了不纠缠具体的技术细节，本例已经把和具体项目无关的公共部分独立为开源项目。
进入工作目录。
下载使用Docker运行nginx+PHP-fpm路由模式的代码
git clone https://github.com/huzhenghui/Docker-run-nginx-PHP-fpm-web-server-router-from-Windows-share-folder zend-expressive-skeleton  进入项目文件夹
cd zend-expressive-skeleton  更新子模块代码
git submodule update --init  由于Docker主机上的卷需要唯一名称，本文使用一个环境变量。
$env:VOLUME_NAME=&quot;zend-expressive-skeleton&quot;  以管理员权限启动PowerShell，运行把Windows文件夹共享到Docker主机的脚本，此处要求docker-machine命令能访问到一台运行中的Docker主机，更多选项请参考其中的源代码。
.\share-windows-folder-to-docker\share-windows-folder-to-docker.ps1 -workingDir . -volumeName ${env:VOLUME_NAME}  测试卷的加载情况。
docker run --rm -v ${env:VOLUME_NAME}:/nginx-PHP-fpm-web-server-router alpine ls /nginx-PHP-fpm-web-server-router  显示文件夹的内容即代表共享成功。
LICENSE docker-compose.yml nginx php share-windows-folder-to-docker  交互安装模式 在公共部分的基础上，可以交互安装。
先删除原有位置的代码。
docker run -it --rm -v ${env:VOLUME_NAME}:/nginx-PHP-fpm-web-server-router --entrypoint /bin/sh alpine -c &quot;rm -rf /nginx-PHP-fpm-web-server-router/php&quot;  然后安装。
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/huzhenghui/docker/docker-run-nginx-php-fpm-web-server-router-from-windows-share-folder/" class="link black dim">
        （开包即用，不用看代码！）在 Docker 中用 nginx 和 PHP-fpm 运行来自 Windows 共享文件夹的路由模式网站
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      CSDN博客
微博文章
微博
准备  PowerShell git docker 使用docker-machine命令可以找到一台可用的Docker主机  开包即用，不用看代码！ 初始化 进入一个文件夹。
下载已经写好的开源项目
git clone https://github.com/huzhenghui/Docker-run-nginx-PHP-fpm-web-server-router-from-Windows-share-folder  进入开源项目文件夹
cd Docker-run-nginx-PHP-fpm-web-server-router-from-Windows-share-folder  更新子模块代码
git submodule update --init  使用管理员权限的PowerShell运行共享文件夹到Docker的脚本。
.\share-windows-folder-to-docker\share-windows-folder-to-docker.ps1 -workingDir . -volumeName nginx-PHP-fpm-web-server-router  查看文件夹是否共享成功
docker run --rm -v nginx-PHP-fpm-web-server-router:/share alpine ls /share  如果成功将看到开源项目的如下文件列表
LICENSE docker-compose.yml nginx php share-windows-folder-to-docker  使用PHP内建的Web Server的路由方式 启动PHP内建web server
docker run -it --rm -v nginx-PHP-fpm-web-server-router:/nginx-PHP-fpm-web-server-router -p 80:80 php -S 0.0.0.0:80 -t /nginx-PHP-fpm-web-server-router/php/public index.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/huzhenghui/docker/docker-run-nginx-php-fpm-web-server-from-windows-share-folder/" class="link black dim">
        （开包即用，不用看代码！）在 Docker 中用 nginx 和 PHP-fpm 运行来自 Windows 共享文件夹的网站
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      CSDN博客
微博文章
微博
准备  PowerShell git docker 使用docker-machine命令可以找到一台可用的Docker主机  开包即用，不用看代码！ 初始化 进入一个文件夹。
下载已经写好的开源项目
git clone https://github.com/huzhenghui/Docker-run-nginx-PHP-fpm-web-server-from-Windows-share-folder  进入开源项目文件夹
cd Docker-run-nginx-PHP-fpm-web-server-from-Windows-share-folder  更新子模块代码
git submodule update --init  使用管理员权限的PowerShell运行共享文件夹到Docker的脚本。
.\share-windows-folder-to-docker\share-windows-folder-to-docker.ps1 -workingDir . -volumeName nginx-PHP-fpm-web-server  查看文件夹是否共享成功
docker run --rm -v nginx-PHP-fpm-web-server:/share alpine ls /share  如果成功将看到开源项目的如下文件列表
LICENSE docker-compose.yml nginx php share-windows-folder-to-docker  使用PHP内建的Web Server 启动PHP内建web server
docker run -it --rm -v nginx-PHP-fpm-web-server:/nginx-PHP-fpm-web-server -p 80:80 php -S 0.0.0.0:80 -t /nginx-PHP-fpm-web-server/php/public  正确启动将看到如下信息
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/opencv" class="link blue hover-black">
            Tag: opencv
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-09-09-opencv-javacv%E5%AE%9E%E7%8E%B0%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/" class="link black dim">
        OpenCV&#43;JavaCV实现人脸识别
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
OpenCV主要实现人脸检测功能
JavaCV主要实现人脸对比功能
具体的就不啰嗦了，本来最近很忙，主要是因为好多人私信我要 Android使用OpenCV实现「人脸检测」和「人脸识别」 的Demo，今天特意抽出时间写了一下。
效果图 源码 KqwFaceDetectionDemo
感觉有用的话，就给个star吧，谢谢！！
注意 最后啰嗦一点，如果你的程序是跑在手机、pad等设备上，一般没有什么问题。 但是如果你是在自己的开发板上跑，可能会有一些小插曲。
比如我司的机器人是定制的Android板子，对系统做了裁剪，很多摄像头的方法可能就用不了
例如这样一个错误
AndroidRuntime: java.lang.RuntimeException: setParameters failed  当打开程序的时候，OpenCV会提示，没有找到可用摄像头或者摄像头被锁住（大概这个意思，我就不截图了），一种可能是设备真的没有接摄像头，也有可能是摄像头定制过，导致某些方法用不了，比如上面的错误就是我遇到的其中一个。
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-22-opencv%E6%A3%80%E6%B5%8B%E5%9B%BE%E5%83%8F%E8%BD%AE%E5%BB%93/" class="link black dim">
        OpenCV检测图像轮廓
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
轮廓只不过是图像中连接的曲线，或者图像中连通部分的边界，轮廓通常以图像中的边缘来计算，但是，边缘和轮廓的区别在于轮廓是闭合的，而边缘可以是任意的。边缘的概念局限于点及其邻域像素，轮廓将目标作为整体进行处理。
效果图 源码 KqwOpenCVFeaturesDemo
步骤  将图像置灰 使用Canny边缘检测检测出图像的边缘 调用Imgproc.findContours()方法检测图像轮廓 在新的图像上画出轮廓  封装 /** * 找出轮廓 * * @param bitmap 要检测的图片 */ public void findContours(Bitmap bitmap) { if (null != mSubscriber) Observable .just(bitmap) // 检测边缘 .map(new Func1&lt;Bitmap, Mat&gt;() { @Override public Mat call(Bitmap bitmap) { Mat grayMat = new Mat(); Mat cannyEdges = new Mat(); // Bitmap转为Mat Mat src = new Mat(bitmap.getHeight(), bitmap.getWidth(), CvType.CV_8UC4); Utils.bitmapToMat(bitmap, src); // 原图置灰 Imgproc.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-22-opencv%E4%BD%BF%E7%94%A8%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E6%A3%80%E6%B5%8B%E5%9B%BE%E5%83%8F%E4%B8%AD%E7%9A%84%E5%BD%A2%E7%8A%B6/" class="link black dim">
        OpenCV使用霍夫变换检测图像中的形状
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
霍夫变换是一种被广泛使用的利用数学等式的参数形式在图像中检测形状的技术。 例如直线、椭圆、圆等形状。
霍夫变换可以检测任何能以参数形式表示的形状，随着形状的复杂（维数的增加，例如球体），计算的消耗也会增加。 我们通常只考虑简单的霍夫形状，例如直线和圆。
源码 KqwOpenCVFeaturesDemo
霍夫直线 效果图 步骤  将图像置灰 调用Imgproc.HoughLinesP(cannyEdges, lines, 1, Math.PI / 180, 50, 20, 20) 方法获取直线的数据
 第一个参数：图像输入 第二个参数：图像输出 第三个参数：图像指定像素中r的解析度 第四个参数：图像指定像素中θ的解析度 第五个参数：直线上点数的阈值 第六个参数：直线上点数的最小值  在图像上绘制直线
  封装 /** * 霍夫直线 * * @param bitmap 要检测的图片 */ public void houghLines(Bitmap bitmap) { if (null != mSubscriber) Observable .just(bitmap) // 检测边缘 .map(new Func1&lt;Bitmap, Mat&gt;() { @Override public Mat call(Bitmap bitmap) { Mat grayMat = new Mat(); Mat cannyEdges = new Mat(); // Bitmap转为Mat Mat src = new Mat(bitmap.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-19-opencv%E4%BD%BF%E7%94%A8harris%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E8%A7%92%E7%82%B9%E6%A3%80%E6%B5%8B/" class="link black dim">
        OpenCV使用Harris算法实现角点检测
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
效果图 源码 KqwOpenCVFeaturesDemo
角点是两条边缘的交点或者在局部邻域中有多个显著边缘方向的点。Harris角点检测是一种在角点检测中最常见的技术。
Harris角点检测器在图像上使用滑动窗口计算亮度的变化。
封装 这里用到了RxJava。主要是因为图片处理是耗时操作，会阻塞线程，为了防止界面卡顿，这里使用RxJava进行了线程切换。
/** * Harris角点检测 * * @param bitmap 要检测的图片 */ public void harris(Bitmap bitmap) { if (null != mSubscriber) Observable .just(bitmap) // 检测边缘 .map(new Func1&lt;Bitmap, Mat&gt;() { @Override public Mat call(Bitmap bitmap) { Mat grayMat = new Mat(); Mat cannyEdges = new Mat(); // Bitmap转为Mat Mat src = new Mat(bitmap.getHeight(), bitmap.getWidth(), CvType.CV_8UC4); Utils.bitmapToMat(bitmap, src); // 原图置灰 Imgproc.cvtColor(src, grayMat, Imgproc.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-19-opencv%E4%BD%BF%E7%94%A8sobel%E6%BB%A4%E6%B3%A2%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/" class="link black dim">
        OpenCV使用Sobel滤波器实现图像边缘检测
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
效果图 源码 KqwOpenCVFeaturesDemo
Sobel滤波器也叫Sobel算子，与Canny边缘检测一样，需要计算像素的灰度梯度，只不过是换用另一种方式。
使用Sobel算子计算边缘的步骤  将图像转为灰度图像
// 原图置灰 Imgproc.cvtColor(src, grayMat, Imgproc.COLOR_BGR2GRAY);  计算水平方向灰度梯度的绝对值
Imgproc.Sobel(grayMat, grad_x, CvType.CV_16S, 1, 0, 3, 1, 0); Core.convertScaleAbs(grad_x, abs_grad_x);  计算垂直方法灰度梯度的绝对值
Imgproc.Sobel(grayMat, grad_y, CvType.CV_16S, 0, 1, 3, 1, 0); Core.convertScaleAbs(grad_y, abs_grad_y);  计算最终梯度
// 计算结果梯度 Core.addWeighted(abs_grad_x, 0.5, abs_grad_y, 0.5, 1, sobel);   最终的梯度实质上就是边缘。
这里用到了两个3 * 3的核对图像做卷积来近似地计算水平和垂直方向的灰度梯度
封装 这里用到了RxJava。主要是因为图片处理是耗时操作，会阻塞线程，为了防止界面卡顿，这里使用RxJava进行了线程切换。
/** * Sobel滤波器 * * @param bitmap 要检测的图片 */ public void sobel(Bitmap bitmap) { if (null !
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-19-opencv%E4%BD%BF%E7%94%A8canny%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/" class="link black dim">
        OpenCV使用Canny边缘检测器实现图像边缘检测
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
效果图 源码 KqwOpenCVFeaturesDemo
Canny边缘检测器是一种被广泛使用的算法，并被认为是边缘检测最优的算法，该方法使用了比高斯差分算法更复杂的技巧，如多向灰度梯度和滞后阈值化。
Canny边缘检测器算法基本步骤  平滑图像：通过使用合适的模糊半径执行高斯模糊来减少图像内的噪声。 计算图像的梯度：这里计算图像的梯度，并将梯度分类为垂直、水平和斜对角。这一步的输出用于在下一步中计算真正的边缘。 非最大值抑制：利用上一步计算出来的梯度方向，检测某一像素在梯度的正方向和负方向上是否是局部最大值，如果是，则抑制该像素（像素不属于边缘）。这是一种边缘细化技术，用最急剧的变换选出边缘点。 用滞后阈值化选择边缘：最后一步，检查某一条边缘是否明显到足以作为最终输出，最后去除所有不明显的边缘。  算法比较复杂，但是使用很简单，首先将图像灰度化
// 原图置灰 Imgproc.cvtColor(src, grayMat, Imgproc.COLOR_BGR2GRAY);  然后调用Imgproc.Canny()方法即可
// Canny边缘检测器检测图像边缘 Imgproc.Canny(grayMat, cannyEdges, 10, 100);   第一个参数表示图像输入 第二个参数表述图像输出 第三个参数表示低阈值 第四个参数表示高阈值  在Canny边缘检测算法中，将图像中的点归为三类：
 被抑制点
灰度梯度值 &lt; 低阈值
 弱边缘点
低阈值 &lt;= 灰度梯度值 &lt;= 高阈值
 强边缘点
高阈值 &lt; 灰度梯度值
  封装 这里用到了RxJava。主要是因为图片处理是耗时操作，会阻塞线程，为了防止界面卡顿，这里使用RxJava进行了线程切换。
/** * Canny边缘检测算法 * * @param bitmap 要检测的图片 */ public void canny(Bitmap bitmap) { if (null !
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-19-opencv%E9%AB%98%E6%96%AF%E5%B7%AE%E5%88%86%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/" class="link black dim">
        OpenCV高斯差分技术实现图像边缘检测
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
效果图 源码 KqwOpenCVFeaturesDemo
边缘是图像中像素亮度变化明显的点。
高斯差分算法步骤  将图像转为灰度图像
// 原图置灰 Imgproc.cvtColor(src, grayMat, Imgproc.COLOR_BGR2GRAY);  用两个不同的模糊半径对灰度图像执行高斯模糊（取得两幅高斯模糊图像）
// 以两个不同的模糊半径对图像做模糊处理 Imgproc.GaussianBlur(grayMat, blur1, new Size(15, 15), 5); Imgproc.GaussianBlur(grayMat, blur2, new Size(21, 21), 5);  将两幅高斯模糊图像做减法，得到一幅包含边缘点的结果图像
// 将两幅模糊后的图像相减 Mat diff = new Mat(); Core.absdiff(blur1, blur2, diff);   该方法只对图像做了高斯模糊，这是计算图像边缘最快的方法之一，但是，该方法的结果也不是很理想，这种方式对某些图像效果很好，但是在某些情况下可能会完全失效。
封装 这里用到了RxJava。主要是因为图片处理是耗时操作，会阻塞线程，为了防止界面卡顿，这里使用RxJava进行了线程切换。
/** * 高斯差分算法边缘检测 * * @param bitmap 要检测的图片 */ public void differenceOfGaussian(Bitmap bitmap) { if (null != mSubscriber) Observable .
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-18-opencv%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%83%8F%E9%98%88%E5%80%BC%E5%8C%96/" class="link black dim">
        OpenCV实现图像阈值化
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
效果图 源码 KqwOpenCVBlurDemo
阈值化是一种将我们想要在图像中分析的区域分割出来的方法。 我们把每个像素值都与一个预设的阈值做比较，再根据比较的结果调整像素值。
类似这样
Imgproc.threshold(src, src, 100, 255, Imgproc.THRESH_BINARY);  其中100是阈值，255是最大值（纯白色的值）。
常量    名称 常量     二值阈值化 Imgproc.THRESH_BINARY   阈值化到零 Imgproc.THRESH_TOZERO   截断阈值化 Imgproc.THRESH_TRUNC   反转二值阈值化 Imgproc.THRESH_BINARY_INV   反转阈值化到零 Imgproc.THRESH_TOZERO_INV    自适应阈值 上述的阈值化是全局性的，我们也可以根据邻域像素为任意像素计算阈值。
自适应阈值用到的3个参数
 自适应方法
 Imgproc.ADAPTIVE_THRESH_MEAN_C：阈值是邻域像素的值 Imgproc.ADAPTIVE_THRESH_GAUSSIAN_C：阈值是领域像素的加权和，权重来自高斯核  块尺寸：邻域的大小
 常量C：从对每个像素计算得到的均值或加权均值减去的常量
  图像置灰
Imgproc.cvtColor(src, src, Imgproc.COLOR_BGR2GRAY);  自适应阈值化
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-18-opencv%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%83%8F%E6%9A%97%E5%8C%BA%E6%89%A9%E5%BC%A0%E8%85%90%E8%9A%80%E5%9B%BE%E7%89%87/" class="link black dim">
        OpenCV实现图像暗区扩张（腐蚀图片）
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
效果图 源码 KqwOpenCVBlurDemo
暗区扩张，也叫腐蚀，要实现这样的效果，我们可以选取一个合适大小的核，用被核覆盖的最小值代替锚点像素。
我们首先定义一个合适大小的核
Mat kernelErode = Imgproc.getStructuringElement(Imgproc.MORPH_ELLIPSE, new Size(5, 5));  然后调用Imgproc.erode()方法把图像的暗区放大
// 扩大暗区（腐蚀） Imgproc.erode(src, src, kernelErode);  封装 这里我用到了RxJava。主要是因为图片处理是耗时操作，会阻塞线程，为了防止界面卡顿，这里使用RxJava进行了线程切换。
/** * 扩大图片暗区（腐蚀图片） * * @param bitmap 要处理的图片 */ public void erode(Bitmap bitmap) { // 使用RxJava处理图片 if (null != mSubscriber) Observable .just(bitmap) .map(new Func1&lt;Bitmap, Bitmap&gt;() { @Override public Bitmap call(Bitmap bitmap) { // Bitmap转为Mat Mat src = new Mat(bitmap.getHeight(), bitmap.getWidth(), CvType.CV_8UC4); Utils.bitmapToMat(bitmap, src); // 定义一个合适大小的核 Mat kernelErode = Imgproc.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-18-opencv%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%83%8F%E4%BA%AE%E5%8C%BA%E6%89%A9%E5%BC%A0/" class="link black dim">
        OpenCV实现图像亮区扩张
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
效果图 源码 KqwOpenCVBlurDemo
亮区扩张，也叫膨胀，要实现这样的效果，我们可以选取一个合适大小的核，用被核覆盖的最大值代替锚点像素。膨胀可以用来融合可能被分割的目标。
我们首先定义一个合适大小的核
Mat kernelDilate = Imgproc.getStructuringElement(Imgproc.MORPH_RECT, new Size(3, 3));  然后调用Imgproc.dilate()方法把图像的亮区放大
// 扩大亮区 Imgproc.dilate(src, src, kernelDilate);  封装 这里我用到了RxJava。主要是因为图片处理是耗时操作，会阻塞线程，为了防止界面卡顿，这里使用RxJava进行了线程切换。
/** * 扩大图片亮区 * * @param bitmap 要处理的图片 */ public void dilate(Bitmap bitmap) { // 使用RxJava处理图片 if (null != mSubscriber) Observable .just(bitmap) .map(new Func1&lt;Bitmap, Bitmap&gt;() { @Override public Bitmap call(Bitmap bitmap) { // Bitmap转为Mat Mat src = new Mat(bitmap.getHeight(), bitmap.getWidth(), CvType.CV_8UC4); Utils.bitmapToMat(bitmap, src); // 定义一个合适大小的核 Mat kernelDilate = Imgproc.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-18-opencv%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E9%94%90%E5%8C%96/" class="link black dim">
        OpenCV实现图片锐化
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
效果图 源码 KqwOpenCVBlurDemo
锐化也可以看作是一种线性滤波操作，并且锚点像素有较高的权重，而周围的像素权重较低。 因此，我们可以自定义一个这样的核。
/* 自定义核 0	-1	0 -1 5	-1 0	-1	0 */ Mat kernel = new Mat(3, 3, CvType.CV_16SC1); kernel.put(0, 0, 0, -1, 0, -1, 5, -1, 0, -1, 0);  这里我们将图像的深度设为16SC1，表示包含一个通道（C1），图像中的每个像素包含一个16比特有符号整型数（16S）。
定义完核以后，我们对图像和核做卷积操作
// 对图像和自定义核做卷积 Imgproc.filter2D(src, src, src.depth(), kernel);   第一个参数表示输入的图像 第二个参数表示输出的图像 第三个参数表示图像的深度 第四个参数是我们自定义的核  封装 这里我用到了RxJava。主要是因为图片处理是耗时操作，会阻塞线程，为了防止界面卡顿，这里使用RxJava进行了线程切换。
/** * 锐化图片 * * @param bitmap 要处理的图片 */ public void filter2D(Bitmap bitmap) { // 使用RxJava处理图片 if (null !
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-18-opencv%E4%B8%AD%E5%80%BC%E6%A8%A1%E7%B3%8A%E6%96%B9%E6%B3%95/" class="link black dim">
        2OpenCV中值模糊方法
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
效果图 源码 KqwOpenCVBlurDemo
步骤  将获取到的Bitmap图片转成Mat对象  // Bitmap转为Mat Mat src = new Mat(bitmap.getHeight(), bitmap.getWidth(), CvType.CV_8UC4); Utils.bitmapToMat(bitmap, src);   调用OpenCV的中值模糊方法  // 中值模糊方法 Imgproc.medianBlur(src, src, 33);   将处理完的Mat数据转成Bitmap对象   // Mat转Bitmap Bitmap processedImage = Bitmap.createBitmap(src.cols(), src.rows(), Bitmap.Config.ARGB_8888); Utils.matToBitmap(src, processedImage);  封装 这里我用到了RxJava。主要是因为图片处理是耗时操作，会阻塞线程，为了防止界面卡顿，这里使用RxJava进行了线程切换。
package kong.qingwei.kqwopencvblurdemo; import android.graphics.Bitmap; import org.opencv.android.Utils; import org.opencv.core.CvType; import org.opencv.core.Mat; import org.opencv.core.Size; import org.opencv.imgproc.Imgproc; import rx.Observable; import rx.Subscriber; import rx.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-17-opencv%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A%E6%96%B9%E6%B3%95/" class="link black dim">
        OpenCV高斯模糊方法
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
效果图 源码 KqwOpenCVBlurDemo
步骤  将获取到的Bitmap图片转成Mat对象  // Bitmap转为Mat Mat src = new Mat(bitmap.getHeight(), bitmap.getWidth(), CvType.CV_8UC4); Utils.bitmapToMat(bitmap, src);   调用OpenCV的高斯模糊方法  // 高斯模糊方法 Imgproc.GaussianBlur(src, src, new Size(91, 91), 0);   将处理完的Mat数据转成Bitmap对象   // Mat转Bitmap Bitmap processedImage = Bitmap.createBitmap(src.cols(), src.rows(), Bitmap.Config.ARGB_8888); Utils.matToBitmap(src, processedImage);  封装 这里我用到了RxJava。主要是因为图片处理是耗时操作，会阻塞线程，为了防止界面卡顿，这里使用RxJava进行了线程切换。
package kong.qingwei.kqwopencvblurdemo; import android.graphics.Bitmap; import org.opencv.android.Utils; import org.opencv.core.CvType; import org.opencv.core.Mat; import org.opencv.core.Size; import org.opencv.imgproc.Imgproc; import rx.Observable; import rx.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-17-opencv%E5%9D%87%E5%80%BC%E6%A8%A1%E7%B3%8A%E6%96%B9%E6%B3%95/" class="link black dim">
        OpenCV均值模糊方法
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
效果图 源码 KqwOpenCVBlurDemo
步骤  将获取到的Bitmap图片转成Mat对象  // Bitmap转为Mat Mat src = new Mat(bitmap.getHeight(), bitmap.getWidth(), CvType.CV_8UC4); Utils.bitmapToMat(bitmap, src);   调用OpenCV的均值模糊方法  // 均值模糊方法 Imgproc.blur(src, src, new Size(100, 100));   将处理完的Mat数据转成Bitmap对象   // Mat转Bitmap Bitmap processedImage = Bitmap.createBitmap(src.cols(), src.rows(), Bitmap.Config.ARGB_8888); Utils.matToBitmap(src, processedImage);  封装 这里我用到了RxJava。主要是因为图片处理是耗时操作，会阻塞线程，为了防止界面卡顿，这里使用RxJava进行了线程切换。
package kong.qingwei.kqwopencvblurdemo; import android.graphics.Bitmap; import org.opencv.android.Utils; import org.opencv.core.CvType; import org.opencv.core.Mat; import org.opencv.core.Size; import org.opencv.imgproc.Imgproc; import rx.Observable; import rx.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-17-opencv%E7%9A%84%E9%83%A8%E7%BD%B2/" class="link black dim">
        OpenCV的部署
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
官网 官网
之前时间比较紧张，在网上找了很多文章，写了一个人脸识别的程序，也是模棱两可，今天开始抽时间系统学习一下OpenCV在Android上的使用。
OpenCV版本 后面用到的是OpenCV的2.4.11版本，据说新的3.x的版本和2.x的版本改动较大，2.x的版本学习完可以再看看与3.x版本的区别。毕竟老版本的学习资源更多一些。
SDK 我们下载完SDK以后，里面会有一个Library的库供我们使用，但是核心的功能不在这里面，它只是一个调用的工具，我们还需要安装OpenCV Manager，在下载的SDK里有一个apk的文件夹，里面是对应各个cup架构的Manager，选择对应的Manager安装就可以了。 除了安装OpenCV Manager，也可以直接在工程里添加so，但是这会使我们的APK体积大大增加，不过这不是我们要关心的，我们主要学习怎么使用OpenCV。
OpenCV的图像存储 OpenCV使用Mat对象存储图像，该对象保存了图像的行数、列数、数据等能唯一标识该图像的信息，并且可以利用该数据还原图像，不同的图像所包含的信息量也不同，例如彩色图像所包含的信息量就要比灰色图像多得多。因为灰色图是单通道的，彩色图是三通道的。
灰色图  数字代表指定颜色的亮度 以整数表示时，取值范围是0~255，0表示纯黑色，255表示纯白色。 以浮点数表示时，取值范围是0~1，0表示纯黑色，1表示纯白色。
 彩色图  第一通道表示蓝色，第二通道表示绿色，第三通道表示红色。
 OpenCV的线性滤波器 有的时候，图像信息量太大，处理的时间就会比较长（有的时候可能不需要这么信息就可以解析出来我们想要的结果了），为了解决这个问题，OpenCV提供了一个线性滤波器，可以对图片进行模糊处理。
很多线性滤波器都利用了称为核的数字向量，核可以看作是沿着像素滑动的窗口，并把计算结果输出给核像素。
下面的图中，是一个3 * 3的核作用在了一副10 * 10的图像上。
创建OpenCV工程 Android Studio版本：2.1
 创建Android Studio工程，命名为FirstOpenCVDemo 导入OpenCV Library
File -&gt; New -&gt; Import Module
 引用OpenCV Library
 安装OpenCV Manager
加载OpenCV Manager，如果诶呦安装会有提示
  private BaseLoaderCallback mOpenCVCallBack = new BaseLoaderCallback(this) { @Override public void onManagerConnected(int status) { switch (status) { case LoaderCallbackInterface.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-07-06-android%E4%BD%BF%E7%94%A8opencv%E5%AE%9E%E7%8E%B0%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/" class="link black dim">
        Android使用OpenCV实现人脸识别
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
效果图 先上效果图，GIF不好弄
在网上找了在Android平台上使用OpenCV相关的教程，很少，大部分也都主要是介绍下人脸检测，很少有讲人脸识别，还有的人连人脸检测和人脸识别的概念都没有搞清，人脸识别只是识别到有人脸，能获取到一个人脸的大概位置，有几个人脸，而人脸识别是要获取到人脸特征做对比，识别这个人脸。有好多文章都写自己在讲人脸识别，实际上他只是在做人脸检测。
OpenCV官网
官方给的Demo是在Eclipse工程下的，如果你现在已经是在Android Studio下开发，因为Eclipse工程有makefile文件，迁移到Android Studio好像还是有点麻烦，我是干脆就在Eclipse下跑的Demo。
先甩过来官方给的一些文档：
OpenCV4Android SDK
Android Development with OpenCV
实现方式 按照官方的文档，我们在Eclipse里导入Demo进去以后，是不能直接运行的，需要安装Manager的一个APK,然后在Demo工程里通过AIDL的方式，调用OpenCV的核心方法，不过Demo给实现的功能也只是一个人脸检测。
SDK SDK下载
下面来看一下SDK
目录：
 apk：Manager的apk doc：一些文档 samples：示例工程和一些编译好的apk sdk：一些库文件   当然, 如果你的C/C++足够好，你肯定可以自己编译一个库，直接导入到工程，就不用安装Manager了，可惜了我自己还不行，哈哈……无奈安装Manager把……
 如何将Demo导入到Eclipse并运行，上面官方的文档已经说的比较清楚了，至于会有什么问题就自行Google吧。
人脸检测 其实人脸检测并不是重点，Demo里已经实现了人脸检测的功能。
主要的实现方式：OpenCV有一个自己的org.opencv.android.JavaCameraView自定义控件，它循环的从摄像头抓取数据，在回调方法中，我们能获取到Mat数据，然后通过调用OpenCV的Native方法，检测当前是否有人脸，我们会获取到一个Rect数组，里面会有人脸数据，最后将人脸画在屏幕上，到此为止，Demo的人脸检测功能，就结束了。
人脸识别 人脸识别我这里用到了JavaCV
人脸识别逻辑：人脸识别的主要方式就是获取到人脸的特征值，然后将两个特征值做比对，取到一个相似度去做人脸识别，OpenCV这里的特征值，其实就是一张图片。 我们的从回调的Mat数据检测到有人脸以后，提取特征值（也就是保存人脸的一张图片到某个路径），然后比较特征值
为了提高识别的准确度，需要在检测到人脸以后，把人脸的部分截取出来，然后置灰（置灰的目的是为了方式色泽和明暗度对识别有影响）。
保存人脸特征值 /** * 特征保存 * * @param image Mat * @param rect 人脸信息 * @param fileName 文件名字 * @return 保存是否成功 */ public boolean saveImage(Mat image, Rect rect, String fileName) { try { String PATH = Environment.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/php" class="link blue hover-black">
            Tag: php
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/huzhenghui/docker/docker-decoupling-operation-tool-and-runtime-tool/" class="link black dim">
        借助Docker解耦合运维工具和运行时工具
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      CSDN博客
微博文章
微博
在部署的时候，经常会遇到这样的情况，运维工具和运行时工具互相干扰，借助Docker可以很方便的解决这个问题，下面以部署Zend Expressive Skeleton为例说明（这个例子中没有运维工具和运行时工具互相干扰的问题，仅用于演示）。
准备 本例假设在Windows操作系统中，Linux的情况可能会更简单些。假设使用docker-machine命令可以访问到一台Docker主机。
公共部分 为了不纠缠具体的技术细节，本例已经把和具体项目无关的公共部分独立为开源项目。
进入工作目录。
下载使用Docker运行nginx+PHP-fpm路由模式的代码
git clone https://github.com/huzhenghui/Docker-run-nginx-PHP-fpm-web-server-router-from-Windows-share-folder zend-expressive-skeleton  进入项目文件夹
cd zend-expressive-skeleton  更新子模块代码
git submodule update --init  由于Docker主机上的卷需要唯一名称，本文使用一个环境变量。
$env:VOLUME_NAME=&quot;zend-expressive-skeleton&quot;  以管理员权限启动PowerShell，运行把Windows文件夹共享到Docker主机的脚本，此处要求docker-machine命令能访问到一台运行中的Docker主机，更多选项请参考其中的源代码。
.\share-windows-folder-to-docker\share-windows-folder-to-docker.ps1 -workingDir . -volumeName ${env:VOLUME_NAME}  测试卷的加载情况。
docker run --rm -v ${env:VOLUME_NAME}:/nginx-PHP-fpm-web-server-router alpine ls /nginx-PHP-fpm-web-server-router  显示文件夹的内容即代表共享成功。
LICENSE docker-compose.yml nginx php share-windows-folder-to-docker  交互安装模式 在公共部分的基础上，可以交互安装。
先删除原有位置的代码。
docker run -it --rm -v ${env:VOLUME_NAME}:/nginx-PHP-fpm-web-server-router --entrypoint /bin/sh alpine -c &quot;rm -rf /nginx-PHP-fpm-web-server-router/php&quot;  然后安装。
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/huzhenghui/docker/docker-run-nginx-php-fpm-web-server-router-from-windows-share-folder/" class="link black dim">
        （开包即用，不用看代码！）在 Docker 中用 nginx 和 PHP-fpm 运行来自 Windows 共享文件夹的路由模式网站
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      CSDN博客
微博文章
微博
准备  PowerShell git docker 使用docker-machine命令可以找到一台可用的Docker主机  开包即用，不用看代码！ 初始化 进入一个文件夹。
下载已经写好的开源项目
git clone https://github.com/huzhenghui/Docker-run-nginx-PHP-fpm-web-server-router-from-Windows-share-folder  进入开源项目文件夹
cd Docker-run-nginx-PHP-fpm-web-server-router-from-Windows-share-folder  更新子模块代码
git submodule update --init  使用管理员权限的PowerShell运行共享文件夹到Docker的脚本。
.\share-windows-folder-to-docker\share-windows-folder-to-docker.ps1 -workingDir . -volumeName nginx-PHP-fpm-web-server-router  查看文件夹是否共享成功
docker run --rm -v nginx-PHP-fpm-web-server-router:/share alpine ls /share  如果成功将看到开源项目的如下文件列表
LICENSE docker-compose.yml nginx php share-windows-folder-to-docker  使用PHP内建的Web Server的路由方式 启动PHP内建web server
docker run -it --rm -v nginx-PHP-fpm-web-server-router:/nginx-PHP-fpm-web-server-router -p 80:80 php -S 0.0.0.0:80 -t /nginx-PHP-fpm-web-server-router/php/public index.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/huzhenghui/docker/docker-run-nginx-php-fpm-web-server-from-windows-share-folder/" class="link black dim">
        （开包即用，不用看代码！）在 Docker 中用 nginx 和 PHP-fpm 运行来自 Windows 共享文件夹的网站
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      CSDN博客
微博文章
微博
准备  PowerShell git docker 使用docker-machine命令可以找到一台可用的Docker主机  开包即用，不用看代码！ 初始化 进入一个文件夹。
下载已经写好的开源项目
git clone https://github.com/huzhenghui/Docker-run-nginx-PHP-fpm-web-server-from-Windows-share-folder  进入开源项目文件夹
cd Docker-run-nginx-PHP-fpm-web-server-from-Windows-share-folder  更新子模块代码
git submodule update --init  使用管理员权限的PowerShell运行共享文件夹到Docker的脚本。
.\share-windows-folder-to-docker\share-windows-folder-to-docker.ps1 -workingDir . -volumeName nginx-PHP-fpm-web-server  查看文件夹是否共享成功
docker run --rm -v nginx-PHP-fpm-web-server:/share alpine ls /share  如果成功将看到开源项目的如下文件列表
LICENSE docker-compose.yml nginx php share-windows-folder-to-docker  使用PHP内建的Web Server 启动PHP内建web server
docker run -it --rm -v nginx-PHP-fpm-web-server:/nginx-PHP-fpm-web-server -p 80:80 php -S 0.0.0.0:80 -t /nginx-PHP-fpm-web-server/php/public  正确启动将看到如下信息
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/huzhenghui/php/test-php-cve-2018-5711-by-docker/" class="link black dim">
        使用 Docker 测试 PHP CVE-2018-5711 漏洞
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      CSDN博客
微博文章
微博
漏洞说明 编号为PHP CVE-2018-5711的漏洞能让运行PHP的服务器瞬间宕机，原理是gd库在遇到特定非法格式的gif图片时会耗尽CPU，影响范围如下：
 PHP 5 &lt; 5.6.33 PHP 7.0 &lt; 7.0.27 PHP 7.1 &lt; 7.1.13 PHP 7.2 &lt; 7.2.1  其中列出的都是该系列的最高版本，也就是说几乎所有使用gd库的PHP都需要为此更新到最高版本。
下面介绍这个漏洞在Docker中验证的方法，需要强调，这里提供了非法格式的git图片文件，如果上传到没有更新的服务器，不排除服务器宕机的可能，造成经济损失将违反相关法律。
PHP 7.2.0版本中的漏洞 下载代码
git clone https://github.com/huzhenghui/Test-7-2-0-PHP-CVE-2018-5711.git  进入项目文件夹
cd Test-7-2-0-PHP-CVE-2018-5711  构建Docker镜像
docker build -t test-7-2-0-php-cve-2018-5711 .  构建成功后查看PHP版本
docker run --rm test-7-2-0-php-cve-2018-5711 -v  可以看到
PHP 7.2.0 (cli) (built: Jan 4 2018 01:20:58) ( NTS ) Copyright (c) 1997-2017 The PHP Group Zend Engine v3.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/huzhenghui/php/object-added-as-fully-reserved-classname-since-php-7.2/" class="link black dim">
        PHP 7.2禁止类名为Object的巨坑
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      CSDN博客
微博文章
微博
PHP 7.2禁止类名为Object的巨坑 2018年1月4日PHP 7.2.1发布，很多之前处于观望的小伙伴开始打算升级PHP了，不过要注意到2017年11月30日发布的PHP 7.2.0开始禁止类名为Object，这将导致很多包出错。特别是很多包的兼容性只写了最低版本，没有写最高版本，使用PHP 7.2的时候composer并不会提示兼容性错误，而PHP的autoload的延迟加载特性，又会导致仅在涉及的时候才会提示错误。例如这样的场景： 程序使用框架F，使用第三方模块M，而模块M中在特定参数的情况会调用模块N，模块N中包含一个类名为Object的类。在开发的时候，模块N并不会涉及到，因此在PHP 7.2中开发很久也不会遇到这个问题。可是给客户部署的时候，出现了使用模块N的情况。
这时候，如果降级到PHP 7.1，那么程序中已经大量使用的PHP 7.2的特性就都需要修改，特别是禁止类名使用Object的特性的根源——Object类型提示，就全部要修改，而且需要增加相应的程序判断。
如果不降级，那么就需要修改模块N中所有涉及到Object的地方，程序员都知道修改别人的代码多么痛苦。
最后说说这个坑。
PHP 7.2.0 Released 中包含 Object typehint 对象类型提示 ，其中提到 Backward Incompatible Changes 向后兼容变更
 Although &lsquo;object&rsquo; is already a soft reserved word, this RFC adds object as fully reserved classname.
 从这里可以看出，object一直是一个软soft保留字，程序中本来就不应该使用，这次只不过变成了完全保留字而已。
例如 yii2 也做了修改 https://github.com/yiisoft/yii2/blob/master/framework/base/Object.php
尽管这么大的坑，不过好处也多多，官方给出的例子如下：
参数类型 function acceptsObject(object $obj) { ... } // This code can be statically analyzed to be correct acceptsObject(json_decode('{}')); // This code can be statically analyzed to be correct acceptsObject(new \MyObject()); // This can be statically analysed to contain an error.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/huzhenghui/docker/docker-run-a-single-php-script-from-windows-share-folder/" class="link black dim">
        在 Docker 中运行来自 Windows 共享文件夹的 PHP 脚本
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      CSDN博客
微博文章
微博讨论
在 Docker 中运行 PHP 程序的一种方式是在Dockerfile中使用COPY命令复制源代码到Docker容器中，如果是在本机中，也可以把本地PHP项目文件夹加载到Docker容器中。如果是虚拟机，例如Docker for Windows在Hyper-V中安装的虚拟机，Docker客户端会自动创建共享文件夹到虚拟机中，而对于使用docker-machine命令创建的虚拟机，Docker客户端就不自动管理了，如果是固定位置运行的程序，可以手工设置共享文件夹，如果是临时运行的话，手工设置共享文件夹未免有些繁琐，此时可以借助PowerShell脚本完成共享操作。
假设电脑上的docker-machine中包含一台docker主机且运行正常，不限于本机、本机中的虚拟机或者其他位置，只要在局域网中能相互访问即可。
使用管理员角色启动PowerShell。
下载示例代码。
git clone https://github.com/huzhenghui/Docker-run-a-single-PHP-script-from-Windows-share-folder  进入项目目录。
cd Docker-run-a-single-PHP-script-from-Windows-share-folder  更新子模块。
git submodule update --init  运行自动共享脚本。
share-windows-folder-to-docker/share-windows-folder-to-docker.ps1 -workingDir ./src -volumeName Docker-run-a-single-PHP-script-from-Windows-share-folder  该脚本将自动把示例项目中的./src文件夹共享到Docker主机中的卷。
测试共享。
docker run --rm -v Docker-run-a-single-PHP-script-from-Windows-share-folder:/share alpine ls /share  将看到列出文件夹中的文件
phpinfo.php  运行PHP程序
docker run -it --rm -v Docker-run-a-single-PHP-script-from-Windows-share-folder:/src -w /src php:latest php phpinfo.php  可以看到输出运行结果。
这种方式把Docker容器作为PHP的运行时环境，而不是单独的PHP程序，因此只需要一个PHP镜像，不需要单独为每个程序创建镜像。例如PHP程序消耗较大的计算资源，而又希望程序和输入、输出的文件都保存在Windows设备时，就适合使用这种方式。
使用的方式也很简单，直接在项目中引入即可。
git submodule add https://github.com/huzhenghui/share-windows-folder-to-docker  
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/powershell" class="link blue hover-black">
            Tag: powershell
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/huzhenghui/docker/docker-run-nginx-php-fpm-web-server-router-from-windows-share-folder/" class="link black dim">
        （开包即用，不用看代码！）在 Docker 中用 nginx 和 PHP-fpm 运行来自 Windows 共享文件夹的路由模式网站
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      CSDN博客
微博文章
微博
准备  PowerShell git docker 使用docker-machine命令可以找到一台可用的Docker主机  开包即用，不用看代码！ 初始化 进入一个文件夹。
下载已经写好的开源项目
git clone https://github.com/huzhenghui/Docker-run-nginx-PHP-fpm-web-server-router-from-Windows-share-folder  进入开源项目文件夹
cd Docker-run-nginx-PHP-fpm-web-server-router-from-Windows-share-folder  更新子模块代码
git submodule update --init  使用管理员权限的PowerShell运行共享文件夹到Docker的脚本。
.\share-windows-folder-to-docker\share-windows-folder-to-docker.ps1 -workingDir . -volumeName nginx-PHP-fpm-web-server-router  查看文件夹是否共享成功
docker run --rm -v nginx-PHP-fpm-web-server-router:/share alpine ls /share  如果成功将看到开源项目的如下文件列表
LICENSE docker-compose.yml nginx php share-windows-folder-to-docker  使用PHP内建的Web Server的路由方式 启动PHP内建web server
docker run -it --rm -v nginx-PHP-fpm-web-server-router:/nginx-PHP-fpm-web-server-router -p 80:80 php -S 0.0.0.0:80 -t /nginx-PHP-fpm-web-server-router/php/public index.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/huzhenghui/docker/docker-run-nginx-php-fpm-web-server-from-windows-share-folder/" class="link black dim">
        （开包即用，不用看代码！）在 Docker 中用 nginx 和 PHP-fpm 运行来自 Windows 共享文件夹的网站
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      CSDN博客
微博文章
微博
准备  PowerShell git docker 使用docker-machine命令可以找到一台可用的Docker主机  开包即用，不用看代码！ 初始化 进入一个文件夹。
下载已经写好的开源项目
git clone https://github.com/huzhenghui/Docker-run-nginx-PHP-fpm-web-server-from-Windows-share-folder  进入开源项目文件夹
cd Docker-run-nginx-PHP-fpm-web-server-from-Windows-share-folder  更新子模块代码
git submodule update --init  使用管理员权限的PowerShell运行共享文件夹到Docker的脚本。
.\share-windows-folder-to-docker\share-windows-folder-to-docker.ps1 -workingDir . -volumeName nginx-PHP-fpm-web-server  查看文件夹是否共享成功
docker run --rm -v nginx-PHP-fpm-web-server:/share alpine ls /share  如果成功将看到开源项目的如下文件列表
LICENSE docker-compose.yml nginx php share-windows-folder-to-docker  使用PHP内建的Web Server 启动PHP内建web server
docker run -it --rm -v nginx-PHP-fpm-web-server:/nginx-PHP-fpm-web-server -p 80:80 php -S 0.0.0.0:80 -t /nginx-PHP-fpm-web-server/php/public  正确启动将看到如下信息
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/huzhenghui/docker/docker-run-a-single-php-script-from-windows-share-folder/" class="link black dim">
        在 Docker 中运行来自 Windows 共享文件夹的 PHP 脚本
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      CSDN博客
微博文章
微博讨论
在 Docker 中运行 PHP 程序的一种方式是在Dockerfile中使用COPY命令复制源代码到Docker容器中，如果是在本机中，也可以把本地PHP项目文件夹加载到Docker容器中。如果是虚拟机，例如Docker for Windows在Hyper-V中安装的虚拟机，Docker客户端会自动创建共享文件夹到虚拟机中，而对于使用docker-machine命令创建的虚拟机，Docker客户端就不自动管理了，如果是固定位置运行的程序，可以手工设置共享文件夹，如果是临时运行的话，手工设置共享文件夹未免有些繁琐，此时可以借助PowerShell脚本完成共享操作。
假设电脑上的docker-machine中包含一台docker主机且运行正常，不限于本机、本机中的虚拟机或者其他位置，只要在局域网中能相互访问即可。
使用管理员角色启动PowerShell。
下载示例代码。
git clone https://github.com/huzhenghui/Docker-run-a-single-PHP-script-from-Windows-share-folder  进入项目目录。
cd Docker-run-a-single-PHP-script-from-Windows-share-folder  更新子模块。
git submodule update --init  运行自动共享脚本。
share-windows-folder-to-docker/share-windows-folder-to-docker.ps1 -workingDir ./src -volumeName Docker-run-a-single-PHP-script-from-Windows-share-folder  该脚本将自动把示例项目中的./src文件夹共享到Docker主机中的卷。
测试共享。
docker run --rm -v Docker-run-a-single-PHP-script-from-Windows-share-folder:/share alpine ls /share  将看到列出文件夹中的文件
phpinfo.php  运行PHP程序
docker run -it --rm -v Docker-run-a-single-PHP-script-from-Windows-share-folder:/src -w /src php:latest php phpinfo.php  可以看到输出运行结果。
这种方式把Docker容器作为PHP的运行时环境，而不是单独的PHP程序，因此只需要一个PHP镜像，不需要单独为每个程序创建镜像。例如PHP程序消耗较大的计算资源，而又希望程序和输入、输出的文件都保存在Windows设备时，就适合使用这种方式。
使用的方式也很简单，直接在项目中引入即可。
git submodule add https://github.com/huzhenghui/share-windows-folder-to-docker  
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/sklearn" class="link blue hover-black">
            Tag: sklearn
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/thinkgamer/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90%E4%B9%8Bsklearn%E5%AE%9E%E7%8E%B0%E7%94%B5%E5%8A%9B%E9%A2%84%E6%B5%8B/" class="link black dim">
        回归分析之Sklearn实现电力预测
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      参考原文：http://www.cnblogs.com/pinard/p/6016029.html 这里进行了手动实现，增强记忆。 
1：数据集介绍 使用的数据是UCI大学公开的机器学习数据
数据的介绍在这： http://archive.ics.uci.edu/ml/datasets/Combined+Cycle+Power+Plant
数据的下载地址在这：http://archive.ics.uci.edu/ml/machine-learning-databases/00294/
里面是一个循环发电场的数据，共有9568个样本数据，每个数据有5列，分别是:AT（温度）, V（压力）, AP（湿度）, RH（压强）, PE（输出电力)。我们不用纠结于每项具体的意思。
我们的问题是得到一个线性的关系，对应PE是样本输出，而AT/V/AP/RH这4个是样本特征， 机器学习的目的就是得到一个线性回归模型，即:
$$ PE = \theta _{0} + \theta _{0} * AT + \theta _{0} * V +\theta _{0} * AP +\theta _{0}*RH $$
而需要学习的，就是θ0,θ1,θ2,θ3,θ4这5个参数。
2：准备数据 下载源数据之后，解压会得到一个xlsx的文件，打开另存为csv文件，数据已经整理好，没有非法数据，但是数据并没有进行归一化，不过这里我们可以使用sklearn来帮我处理
sklearn的归一化处理参考：http://blog.csdn.net/gamer_gyt/article/details/77761884
3：使用pandas来进行数据的读取 import pandas as pd # pandas 读取数据 data = pd.read_csv(&quot;Folds5x2_pp.csv&quot;) data.head()  然后会看到如下结果，说明数据读取成功：
	AT	V	AP	RH	PE 0	8.34	40.77	1010.84	90.01	480.48 1	23.64	58.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/thinkgamer/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BD%92%E4%B8%80%E5%8C%96%E5%92%8C%E5%85%B6%E5%9C%A8sklearn%E4%B8%AD%E7%9A%84%E5%A4%84%E7%90%86/" class="link black dim">
        数据归一化和其在sklearn中的处理
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      一：数据归一化 数据归一化（标准化）处理是数据挖掘的一项基础工作，不同评价指标往往具有不同的量纲和量纲单位，这样的情况会影响到数据分析的结果，为了消除指标之间的量纲影响，需要进行数据标准化处理，以解决数据指标之间的可比性。原始数据经过数据标准化处理后，各指标处于同一数量级，适合进行综合对比评价。  归一化方法有两种形式，一种是把数变为（0，1）之间的小数，一种是把有量纲表达式变为无量纲表达式。在机器学习中我们更关注的把数据变到0～1之间，接下来我们讨论的也是第一种形式。
1）min-max标准化 min-max标准化也叫做离差标准化，是对原始数据的线性变换，使结果落到[0,1]区间，其对应的数学公式如下：
$$ X_{scale} = \frac{x-min}{max-min} $$
对应的python实现为
# x为数据 比如说 [1,2,1,3,2,4,1] def Normalization(x): return [(float(i)-min(x))/float(max(x)-min(x)) for i in x]  如果要将数据转换到[-1,1]之间，可以修改其数学公式为：
$$ X{scale} = \frac{x-x{mean}}{max-min} $$ x_mean 表示平均值。
对应的python实现为
import numpy as np # x为数据 比如说 [1,2,1,3,2,4,1] def Normalization(x): return [(float(i)-np.mean(x))/float(max(x)-min(x)) for i in x]  其中max为样本数据的最大值，min为样本数据的最小值。这种方法有个缺陷就是当有新数据加入时，可能导致max和min的变化，需要重新定义。
该标准化方法有一个缺点就是，如果数据中有一些偏离正常数据的异常点，就会导致标准化结果的不准确性。比如说一个公司员工（A，B，C，D）的薪水为6k,8k,7k,10w,这种情况下进行归一化对每个员工来讲都是不合理的。
当然还有一些其他的办法也能实现数据的标准化。
2）z-score标准化 z-score标准化也叫标准差标准化，代表的是分值偏离均值的程度，经过处理的数据符合标准正态分布，即均值为0，标准差为1。其转化函数为
$$ X_{scale} = \frac{x-\mu }{\sigma } $$
其中μ为所有样本数据的均值，σ为所有样本数据的标准差。
其对应的python实现为：
import numpy as np #x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] def z_score(x): return (x - np.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/windows" class="link blue hover-black">
            Tag: windows
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/huzhenghui/docker/docker-run-nginx-php-fpm-web-server-router-from-windows-share-folder/" class="link black dim">
        （开包即用，不用看代码！）在 Docker 中用 nginx 和 PHP-fpm 运行来自 Windows 共享文件夹的路由模式网站
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      CSDN博客
微博文章
微博
准备  PowerShell git docker 使用docker-machine命令可以找到一台可用的Docker主机  开包即用，不用看代码！ 初始化 进入一个文件夹。
下载已经写好的开源项目
git clone https://github.com/huzhenghui/Docker-run-nginx-PHP-fpm-web-server-router-from-Windows-share-folder  进入开源项目文件夹
cd Docker-run-nginx-PHP-fpm-web-server-router-from-Windows-share-folder  更新子模块代码
git submodule update --init  使用管理员权限的PowerShell运行共享文件夹到Docker的脚本。
.\share-windows-folder-to-docker\share-windows-folder-to-docker.ps1 -workingDir . -volumeName nginx-PHP-fpm-web-server-router  查看文件夹是否共享成功
docker run --rm -v nginx-PHP-fpm-web-server-router:/share alpine ls /share  如果成功将看到开源项目的如下文件列表
LICENSE docker-compose.yml nginx php share-windows-folder-to-docker  使用PHP内建的Web Server的路由方式 启动PHP内建web server
docker run -it --rm -v nginx-PHP-fpm-web-server-router:/nginx-PHP-fpm-web-server-router -p 80:80 php -S 0.0.0.0:80 -t /nginx-PHP-fpm-web-server-router/php/public index.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/huzhenghui/docker/docker-run-nginx-php-fpm-web-server-from-windows-share-folder/" class="link black dim">
        （开包即用，不用看代码！）在 Docker 中用 nginx 和 PHP-fpm 运行来自 Windows 共享文件夹的网站
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      CSDN博客
微博文章
微博
准备  PowerShell git docker 使用docker-machine命令可以找到一台可用的Docker主机  开包即用，不用看代码！ 初始化 进入一个文件夹。
下载已经写好的开源项目
git clone https://github.com/huzhenghui/Docker-run-nginx-PHP-fpm-web-server-from-Windows-share-folder  进入开源项目文件夹
cd Docker-run-nginx-PHP-fpm-web-server-from-Windows-share-folder  更新子模块代码
git submodule update --init  使用管理员权限的PowerShell运行共享文件夹到Docker的脚本。
.\share-windows-folder-to-docker\share-windows-folder-to-docker.ps1 -workingDir . -volumeName nginx-PHP-fpm-web-server  查看文件夹是否共享成功
docker run --rm -v nginx-PHP-fpm-web-server:/share alpine ls /share  如果成功将看到开源项目的如下文件列表
LICENSE docker-compose.yml nginx php share-windows-folder-to-docker  使用PHP内建的Web Server 启动PHP内建web server
docker run -it --rm -v nginx-PHP-fpm-web-server:/nginx-PHP-fpm-web-server -p 80:80 php -S 0.0.0.0:80 -t /nginx-PHP-fpm-web-server/php/public  正确启动将看到如下信息
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/huzhenghui/docker/docker-run-a-single-php-script-from-windows-share-folder/" class="link black dim">
        在 Docker 中运行来自 Windows 共享文件夹的 PHP 脚本
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      CSDN博客
微博文章
微博讨论
在 Docker 中运行 PHP 程序的一种方式是在Dockerfile中使用COPY命令复制源代码到Docker容器中，如果是在本机中，也可以把本地PHP项目文件夹加载到Docker容器中。如果是虚拟机，例如Docker for Windows在Hyper-V中安装的虚拟机，Docker客户端会自动创建共享文件夹到虚拟机中，而对于使用docker-machine命令创建的虚拟机，Docker客户端就不自动管理了，如果是固定位置运行的程序，可以手工设置共享文件夹，如果是临时运行的话，手工设置共享文件夹未免有些繁琐，此时可以借助PowerShell脚本完成共享操作。
假设电脑上的docker-machine中包含一台docker主机且运行正常，不限于本机、本机中的虚拟机或者其他位置，只要在局域网中能相互访问即可。
使用管理员角色启动PowerShell。
下载示例代码。
git clone https://github.com/huzhenghui/Docker-run-a-single-PHP-script-from-Windows-share-folder  进入项目目录。
cd Docker-run-a-single-PHP-script-from-Windows-share-folder  更新子模块。
git submodule update --init  运行自动共享脚本。
share-windows-folder-to-docker/share-windows-folder-to-docker.ps1 -workingDir ./src -volumeName Docker-run-a-single-PHP-script-from-Windows-share-folder  该脚本将自动把示例项目中的./src文件夹共享到Docker主机中的卷。
测试共享。
docker run --rm -v Docker-run-a-single-PHP-script-from-Windows-share-folder:/share alpine ls /share  将看到列出文件夹中的文件
phpinfo.php  运行PHP程序
docker run -it --rm -v Docker-run-a-single-PHP-script-from-Windows-share-folder:/src -w /src php:latest php phpinfo.php  可以看到输出运行结果。
这种方式把Docker容器作为PHP的运行时环境，而不是单独的PHP程序，因此只需要一个PHP镜像，不需要单独为每个程序创建镜像。例如PHP程序消耗较大的计算资源，而又希望程序和输入、输出的文件都保存在Windows设备时，就适合使用这种方式。
使用的方式也很简单，直接在项目中引入即可。
git submodule add https://github.com/huzhenghui/share-windows-folder-to-docker  
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/%E4%B8%B2%E5%8F%A3" class="link blue hover-black">
            Tag: 串口
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-11-01-android%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/" class="link black dim">
        Android串口通信
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
 串口通信偏向嵌入式一点，是Android设备通过串口与其他设备进行通信的一种方式，本文介绍的Android纯串口的通信，并不是手机上的USB串口通信。
  手机上是没有这个串口的哦。
 关于串口通信，Google已经给出了源码，地址在GitHub android-serialport-api
四年前的代码，还是Eclipse工程，本文主要介绍如何在Android Studio中使用。
源码地址在 KqwSerialPortDemo
集成 Java层的代码，Google已经给封装在 SerialPort.java
导入.so 没有什么难度了，将so导入到项目
导入jni文件 在main目录下创建cpp文件夹，并将jni源文件和CMakeLists.txt导入
在build.gradle配置cmake路径。
android { …… externalNativeBuild { cmake { path &quot;src/main/cpp/CMakeLists.txt&quot; } } …… ｝  修改jni源文件 这里要注意jni文件函数名的写法：Java_包名_类名_方法名
在将源码里的jni导入过来的时候，包名是源码Demo的包名，我们在自己的工程里要换成自己的包名、类名，源文件和头文件都要记得改。
修改CMakeLists.txt与SerialPort.java CMakeLists.txt
cmake_minimum_required(VERSION 3.4.1) add_library(SerialPort SHARED SerialPort.c) # Include libraries needed for libserial_port lib target_link_libraries(SerialPort android log)  SerialPort.java
static { System.loadLibrary(&quot;SerialPort&quot;); System.loadLibrary(&quot;serial_port&quot;); }  使用 基类 需要使用串口通信的类继承 SerialPortActivity.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/%E5%8A%A0%E5%AF%86" class="link blue hover-black">
            Tag: 加密
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2017-08-04-android-aes-%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/" class="link black dim">
        Android AES 加密、解密
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      AES加密介绍
ASE 加密、解密的关键在于秘钥、只有使用加密时使用的秘钥，才可以解密。
生成秘钥的代码网上一大堆，下面的代码可生成一个秘钥
private SecretKey generateKey(String seed) throws Exception { // 获取秘钥生成器 KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;AES&quot;); // 通过种子初始化 SecureRandom secureRandom = new SecureRandom(); secureRandom.setSeed(seed.getBytes(&quot;UTF-8&quot;)); keyGenerator.init(128, secureRandom); // 生成秘钥并返回 return keyGenerator.generateKey(); }  然后使用秘钥进行加密
private byte[] encrypt(String content, SecretKey secretKey) throws Exception { // 秘钥 byte[] enCodeFormat = secretKey.getEncoded(); // 创建AES秘钥 SecretKeySpec key = new SecretKeySpec(enCodeFormat, &quot;AES&quot;); // 创建密码器 Cipher cipher = Cipher.getInstance(&quot;AES&quot;); // 初始化加密器 cipher.init(Cipher.ENCRYPT_MODE, key); // 加密 return cipher.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90" class="link blue hover-black">
            Tag: 动态权限
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2017-02-16-%E6%89%93%E9%80%A0%E7%AE%80%E6%B4%81%E9%AB%98%E6%95%88%E7%9A%84%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%99%A8/" class="link black dim">
        打造简洁高效的动态权限管理器
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
效果图
GitHub地址：PermissionsManager
随着Android 6.0的普及，动态权限的重要性也开始时慢慢体现出来。为了更好的保护用户隐私，Android 6.0要求在进行敏感操作之前，必须要向用户请示申请权限。
如何使用，在之前的文章里也已经介绍过了，但是用起来比较麻烦。Android6.0动态获取权限
我希望可以封装一下，使用之前创建一个动态权限的管理对象，他有两个回调来告诉我权限申请成功或者失败，像这样：
mPermissionsManager = new PermissionsManager(this) { @Override public void authorized(int requestCode) { // TODO 权限通过 } @Override public void noAuthorization(int requestCode, String[] lacksPermissions) { // TODO 有权限没有通过 } };  使用的时候，可以直接调用一个方法，把要请示的权限传进去就可以进行校验，像这样：
// 检查权限 mPermissionsManager.checkPermissions(&quot;请求码&quot;, &quot;要校验的权限&quot;);  于是乎，下面封装的动态权限管理器就来了：
动态权限管理器 package com.kongqw.permissionslibrary; import android.app.Activity; import android.content.Context; import android.content.Intent; import android.content.pm.PackageManager; import android.net.Uri; import android.provider.Settings; import android.support.annotation.NonNull; import android.support.v4.app.ActivityCompat; import android.support.v4.content.ContextCompat; import java.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/%E5%8D%B3%E6%8B%BF%E5%8D%B3%E7%94%A8" class="link blue hover-black">
            Tag: 即拿即用
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2017-09-19-%E5%8D%B3%E6%8B%BF%E5%8D%B3%E7%94%A8android%E6%96%87%E4%BB%B6%E5%AD%98%E5%8F%96/" class="link black dim">
        即拿即用一Android文件存取
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      写文件 读文件 Assets文件读取 Bitmap保存 文件删除  写文件 /** * 写文件 * * @param filePath 文件绝对路径 * @param content 写入内容 * @return 写入是否成功 */ public static boolean writeFile(String filePath, String content) { FileOutputStream fileOutputStream = null; BufferedOutputStream bufferedOutputStream = null; try { File file = new File(filePath); if (file.createNewFile()) { fileOutputStream = new FileOutputStream(filePath); bufferedOutputStream = new BufferedOutputStream(fileOutputStream); bufferedOutputStream.write(content.getBytes(&quot;UTF-8&quot;)); bufferedOutputStream.flush(); return true; } } catch (IOException e) { e.printStackTrace(); } finally { if (null !
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90" class="link blue hover-black">
            Tag: 回归分析
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/thinkgamer/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90%E4%B9%8Bsklearn%E5%AE%9E%E7%8E%B0%E7%94%B5%E5%8A%9B%E9%A2%84%E6%B5%8B/" class="link black dim">
        回归分析之Sklearn实现电力预测
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      参考原文：http://www.cnblogs.com/pinard/p/6016029.html 这里进行了手动实现，增强记忆。 
1：数据集介绍 使用的数据是UCI大学公开的机器学习数据
数据的介绍在这： http://archive.ics.uci.edu/ml/datasets/Combined+Cycle+Power+Plant
数据的下载地址在这：http://archive.ics.uci.edu/ml/machine-learning-databases/00294/
里面是一个循环发电场的数据，共有9568个样本数据，每个数据有5列，分别是:AT（温度）, V（压力）, AP（湿度）, RH（压强）, PE（输出电力)。我们不用纠结于每项具体的意思。
我们的问题是得到一个线性的关系，对应PE是样本输出，而AT/V/AP/RH这4个是样本特征， 机器学习的目的就是得到一个线性回归模型，即:
$$ PE = \theta _{0} + \theta _{0} * AT + \theta _{0} * V +\theta _{0} * AP +\theta _{0}*RH $$
而需要学习的，就是θ0,θ1,θ2,θ3,θ4这5个参数。
2：准备数据 下载源数据之后，解压会得到一个xlsx的文件，打开另存为csv文件，数据已经整理好，没有非法数据，但是数据并没有进行归一化，不过这里我们可以使用sklearn来帮我处理
sklearn的归一化处理参考：http://blog.csdn.net/gamer_gyt/article/details/77761884
3：使用pandas来进行数据的读取 import pandas as pd # pandas 读取数据 data = pd.read_csv(&quot;Folds5x2_pp.csv&quot;) data.head()  然后会看到如下结果，说明数据读取成功：
	AT	V	AP	RH	PE 0	8.34	40.77	1010.84	90.01	480.48 1	23.64	58.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/thinkgamer/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92n%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/" class="link black dim">
        回归分析之线性回归（N元线性回归）
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      在上一篇文章中我们介绍了 回归分析之理论篇，在其中我们有聊到线性回归和非线性回归，包括广义线性回归，这一篇文章我们来聊下回归分析中的线性回归。
 一元线性回归 预测房价： 输入编号 | 平方米 | 价格 -|-|- 1 | 150 | 6450 2 | 200 | 7450 3| 250 |8450 4| 300 |9450 5| 350 |11450 6| 400 |15450 7| 600| 18450
针对上边这种一元数据来讲，我们可以构建的一元线性回归函数为 $$ H(x) = k*x + b $$ 其中H(x)为平方米价格表，k是一元回归系数，b为常数。最小二乘法的公式： $$ k =\frac{ \sum{1}^{n} (x{i} - \bar{x} )(y{i} - \bar{y}) } { \sum{1}^{n}(x_{i}-\bar{x})^{2} } $$ 自己使用python代码实现为：
def leastsq(x,y): &quot;&quot;&quot; x,y分别是要拟合的数据的自变量列表和因变量列表 &quot;&quot;&quot; meanX = sum(x) * 1.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/thinkgamer/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90%E4%B9%8B%E7%90%86%E8%AE%BA%E7%AF%87/" class="link black dim">
        回归分析之理论篇
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      2015年的机器学习博客其实都是看《机器学习实战》这本书时学到的，说实话当时也是知其然，不知其所以然，以至于对其理解不深刻，好多细节和理论知识都搞的是乱七八糟，自从工作之后再去看一个算法，思考的比之前多了点，查看资料也比之前多了点，生怕理解错误，影响其他人，当然在理解的程度上还是不够深刻，这也是一个学习的过程吧，记录一下，欢迎指正。
CSDN链接：点击阅读 
一：一些名词定义 1）指数分布族 指数分布族是指可以表示为指数形式的概率分布。 $$ f_X(x\mid\theta) = h(x) \exp \left (\eta(\theta) \cdot T(x) -A(\theta)\right ) $$ 其中，η为自然参数(nature parameter)，T(x)是充分统计量（sufficient statistic）。当参数A，h，T都固定以后，就定义了一个以η为参数的函数族。
伯努利分布与高斯分布是两个典型的指数分布族
伯努利分布 又名两点分布或者0-1分布，是一个离散型概率分布。假设1的概率为p，0的概率为q，则 其概率质量函数为：
{\displaystyle f_{X}(x)=p^{x}(1-p)^{1-x}=\left\{{\begin{matrix}p&amp;{\mbox{if }}x=1,\\q\ &amp;{\mbox{if }}x=0.\\\end{matrix}}\right.}  其期望值为： $$ {\displaystyle \operatorname {E} [X]=\sum {i=0}^{1}x{i}f_{X}(x)=0+p=p} $$
其方差为： $$ {\displaystyle \operatorname {var} [X]=\sum {i=0}^{1}(x{i}-E[X])^{2}f_{X}(x)=(0-p)^{2}(1-p)+(1-p)^{2}p=p(1-p)=pq} $$
正态分布(高斯分布) 若随机变量X服从一个位置参数为 ${\displaystyle \mu }$ 、尺度参数为 ${\displaystyle \sigma } $ 的概率分布，记为： $$ X \sim N(\mu,\sigma^2), $$
其概率密度函数为:
f(x) = {1 \over \sigma\sqrt{2\pi} }\,e^{- {{(x-\mu )^2 \over 2\sigma^2}}}  正态分布的数学期望值或期望值$ {\displaystyle \mu } $ 等于位置参数，决定了分布的位置；其方差 $ {\displaystyle \sigma ^{2}} $ 的开平方或标准差$ {\displaystyle \sigma }$ 等于尺度参数，决定了分布的幅度。
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/%E5%A3%B0%E9%81%93" class="link blue hover-black">
            Tag: 声道
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-26-android%E5%B7%A6%E5%8F%B3%E5%A3%B0%E9%81%93%E7%9A%84%E6%8E%A7%E5%88%B6/" class="link black dim">
        Android左右声道的控制
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
效果图 源码 AndroidSoundManagerDemo
我这里主要是用到了AudioTrack实现的左右声道的控制，手机一般都只有两个声道，即左声道和右声道，我们在输出的时候可以选择单声道，也可以选择双声道（立体声）。
查看了AudioTrack的API，提供了play()、pause()、stop()、write()等一系列的方法。 通过write()方法，可以实现将音频数据发送出去（播放出来）。
AudioTrack对象的构造 有三个构造方法
AudioTrack (int streamType, int sampleRateInHz, int channelConfig, int audioFormat, int bufferSizeInBytes, int mode) AudioTrack (int streamType, int sampleRateInHz, int channelConfig, int audioFormat, int bufferSizeInBytes, int mode, int sessionId) AudioTrack (AudioAttributes attributes, AudioFormat format, int bufferSizeInBytes, int mode, int sessionId)  主要参数有如下几个
 streamType：以什么形式播放
 STREAM_VOICE_CALL STREAM_SYSTEM STREAM_RING STREAM_MUSIC STREAM_ALARM STREAM_NOTIFICATION  sampleRateInHz：采样率
 channelConfig：声道
 AudioFormat.CHANNEL_OUT_MONO：输出单声道音频数据 AudioFormat.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/%E5%A4%8F%E6%9C%AA%E7%9C%A0" class="link blue hover-black">
            Tag: 夏未眠
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/thinkgamer/%E5%A4%8F%E6%9C%AA%E7%9C%A0/%E8%BF%99%E5%A4%8F%E6%9C%AA%E7%9C%A0-%E7%AE%80%E4%BB%8B/" class="link black dim">
        这夏未眠.简介
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      书整体分为三部分《夏之过往》，《夏之流年》，《夏之未至》。整本书讲的是男主人公顾艾哲（小艾）与莫晨（晨晨）之间的故事，从初中到高中再到大学，从相遇到相知再到相离。  两人同在陌乘一中念初中，同班同学，在中考来临的那段日子，两人相互鼓励，于是顾艾哲（小艾）考上了他从来都没有想过能考上的孟川一高，而莫晨（晨晨）呢，考上了预料之中的平阳一高，而她在这之前却从来没告诉过顾艾哲（小艾）她要去平阳，就这样，两个人分开了，一些都看起来那么顺理成章，一切又看起来那么暗淡失望。
在经历过高中的二年之后，顾艾哲（小艾）终于联系上了莫晨（晨晨），那天晚上，他用妈妈的电话给莫晨（晨晨）通了两个小时的电话，似乎要把两人两年里没有说的话都说完，可是有太多的话是无法用言语表达的，就这样电话欠费了，终止了聊天，可是那天晚上，小艾高兴的一宿没睡，那一晚上，他的笑容都是幸福的。
可是事情永远不会那么顺利，在香山公园里，当他拿起他买的情侣戒指送给晨晨时，晨晨没有接受，说了一堆他也没有听进去的话，就这样，又开始了分离，而谁也不知道这次分离竟然时一辈子的再也不见。
后来的后来，他又遇见了别的女孩，不知道是不是因为后来的女孩都像小艾记忆里的莫晨。只知道，他都很珍惜。
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/thinkgamer/%E5%A4%8F%E6%9C%AA%E7%9C%A0/%E8%BF%99%E5%A4%8F%E6%9C%AA%E7%9C%A0-%E5%BA%8F/" class="link black dim">
        这夏未眠.序
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      这本书的整体构思是小主大学一年级时刚去的时候的一个想法，当时刚刚步入大学的我们，心里是那么的迷茫与懵懂，开学前两周，除了军训还是军训，晚上偶尔有个空闲时间，我想大概也许是无聊的，记得那个时候坐在图书馆靠窗的位置，看着窗外，没有明月，没有佳人，有的只是一望无际的黑暗。  那个时候，还没有遇到你所想遇到的人，或许回忆还沉淀在高中的时光里，或是幸福，或是苦涩，或是幸福之后的苦涩，回过头来，看着满屋子的学长学姐，心里是及其复杂的，有种说不出的难过，那时候我是不是在想，现在的你（们）会在哪里念大学呢？
想着想着眼角便淌出了泪水，我想我的大学要完成一件至少我自己觉得满意的事，于是便有了你现在看到的这个序，不知道是不是受郭敬明的影响，因为我看过他的唯一一本小说，也是我看过的唯一一本小说——《夏至未至》，我想写一本书，或者更准确的说，我想写一个人的青春。
在13年军训结束之后，我构思了整个体系，定了这本书的名字——《这夏未眠》，熟悉我的朋友，也知道这是我的QQ网名，QQ作为那个时代的记忆，总会残留一些悲伤的故事，于是我到现在四年了，我从没换过QQ网名，或许是害怕，害怕那些好久不联系的朋友，找不到我吧。
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/%E5%A4%9A%E5%AA%92%E4%BD%93" class="link blue hover-black">
            Tag: 多媒体
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-11-16-android%E6%92%AD%E6%94%BE%E9%9F%B3%E6%95%88/" class="link black dim">
        Android播放音效
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
有些时候程序需要播放几个很短的低延迟的音效来响应与用户的交互。
Android通过SoundPool将文件音频缓存加载到内存中，然后在响应用户操作的时候快速地播放。 Android框架低通了SoundPool来解码小音频文件，并在内存中操作它们来进行音频快速和重复的播放。SoundPool还有一些其他特性，比如可以在运行时控制音量和播放速度。
播放音效也很简单，总共分5步
准备音频文件 将音频文件放置在assets目录下
初始化SoundPool SoundPool mSoundPool = new SoundPool(1, AudioManager.STREAM_MUSIC, 0);  加载音频文件 int streamID = mSoundPool.load(getApplicationContext().getAssets().openFd(&quot;beep/beep1.mp3&quot;), 1);  播放音频文件 mSoundPool.play(streamID, 10, 10, 1, 0, 1.0f);  释放SoundPool mSoundPool.release(); mSoundPool = null;  Code package com.kongqw.kqwplaybeepdemo; import android.media.AudioManager; import android.media.SoundPool; import android.support.v7.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import android.view.View; import java.io.IOException; import java.util.HashMap; public class MainActivity extends AppCompatActivity implements View.OnClickListener { private static final String TAG = &quot;MainActivity&quot;; private SoundPool mSoundPool; private int streamID; private HashMap&lt;String, Integer&gt; mSoundMap; @Override protected void onCreate(Bundle savedInstanceState) { super.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/%E5%BC%80%E6%BA%90" class="link blue hover-black">
            Tag: 开源
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2017-03-16-android-%E8%93%9D%E7%89%99%E9%80%9A%E4%BF%A1androidbluetoothmanager/" class="link black dim">
        Android蓝牙通信——AndroidBluetoothManager
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN

To get a Git project into your build:
Step 1. Add the JitPack repository to your build file
Add it in your root build.gradle at the end of repositories:
allprojects { repositories { ... maven { url 'https://jitpack.io' } } }  Step 2. Add the dependency
dependencies { compile 'com.github.kongqw:AndroidBluetoothManager:1.0.0' }  AndroidBluetoothManager
效果图 PNG
GIF
基础功能 添加权限 &lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot; /&gt; &lt;uses-permission android:name=&quot;android.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2017-03-10-android%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%B7%E8%BE%BE%E6%89%AB%E6%8F%8F%E6%8E%A7%E4%BB%B6/" class="link black dim">
        Android自定义雷达扫描控件
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
Android 雷达扫描控件 
To get a Git project into your build:
Step 1. Add the JitPack repository to your build file
Add it in your root build.gradle at the end of repositories:
allprojects { repositories { ... maven { url 'https://jitpack.io' } } }  Step 2. Add the dependency
dependencies { compile 'com.github.kongqw:AndroidRadarScanView:1.0.1' }  源码：AndroidRadarScanView
效果图 XML &lt;com.kongqw.radarscanviewlibrary.RadarScanView android:id=&quot;@+id/radarScanView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt;  初始化 radarScanView = (RadarScanView) findViewById(R.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-09-01-android%E8%87%AA%E5%AE%9A%E4%B9%89%E6%91%87%E6%9D%86/" class="link black dim">
        Android自定义摇杆
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
效果图 源码 KqwRockerDemo
喜欢就给个star，谢谢！
功能  支持自适应大小 支持2个方向、4个方向、8个方向的摇动监听 支持摇动角度获取 可选回调模式 支持可摇动区域自定义 支持摇杆自定义 支持设置图片、色值、Shape图形  使用 &lt;kong.qingwei.rockerlibrary.RockerView android:id=&quot;@+id/rockerView_center&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:layout_centerHorizontal=&quot;true&quot; kongqw:areaBackground=&quot;#FF333333&quot; kongqw:rockerBackground=&quot;#FF987654&quot; kongqw:rockerRadius=&quot;15dp&quot; /&gt;  参数    参数 是否必须 描述     areaBackground 可选 可摇动区域的背景   rockerBackground 可选 摇杆的背景   rockerRadius 可选 摇杆半径    设置回调方式 setCallBackMode(CallBackMode mode)  参数
   回调方式 描述     CALL_BACK_MODE_MOVE 有移动就立刻回调   CALL_BACK_MODE_STATE_CHANGE 状态有变化的时候回调    监听摇动角度 返回角度的取值范围：[0°,360°)
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B" class="link blue hover-black">
            Tag: 异常检测
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/thinkgamer/elk/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E4%B9%8B%E6%8C%87%E6%95%B0%E5%B9%B3%E6%BB%91%E5%88%A9%E7%94%A8elasticsearch%E6%9D%A5%E5%AE%9E%E7%8E%B0/" class="link black dim">
        异常检测之指数平滑（利用elasticsearch来实现）
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      指数平滑法是一种特殊的加权平均法，加权的特点是对离预测值较近的历史数据给予较大的权数，对离预测期较远的历史数据给予较小的权数，权数由近到远按指数规律递减，所以，这种预测方法被称为指数平滑法。它可分为一次指数平滑法、二次指数平滑法及更高次指数平滑法。 
关于指数平滑的得相关资料：  ES API接口： &gt; https://github.com/IBBD/IBBD.github.io/blob/master/elk/aggregations-pipeline.md https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-movavg-aggregation.html
 理论概念 &gt; http://blog.sina.com.cn/s/blog_4b9acb5201016nkd.html
  ES移动平均聚合：Moving Average的四种模型 simple 就是使用窗口内的值的和除于窗口值，通常窗口值越大，最后的结果越平滑: (a1 + a2 + &hellip; + an) / n
curl -XPOST 'localhost:9200/_search?pretty' -H 'Content-Type: application/json' -d' { &quot;size&quot;: 0, &quot;aggs&quot;: { &quot;my_date_histo&quot;:{ &quot;date_histogram&quot;:{ &quot;field&quot;:&quot;date&quot;, &quot;interval&quot;:&quot;1M&quot; }, &quot;aggs&quot;:{ &quot;the_sum&quot;:{ &quot;sum&quot;:{ &quot;field&quot;: &quot;price&quot; } }, &quot;the_movavg&quot;:{ &quot;moving_avg&quot;:{ &quot;buckets_path&quot;: &quot;the_sum&quot;, &quot;window&quot; : 30, &quot;model&quot; : &quot;simple&quot; } } } } } } '  线性模型：Linear 对窗口内的值先做线性变换处理，再求平均：(a1 * 1 + a2 * 2 + &hellip; + an * n) / (1 + 2 + &hellip; + n)
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/%E6%91%87%E6%9D%86" class="link blue hover-black">
            Tag: 摇杆
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-09-01-android%E8%87%AA%E5%AE%9A%E4%B9%89%E6%91%87%E6%9D%86/" class="link black dim">
        Android自定义摇杆
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
效果图 源码 KqwRockerDemo
喜欢就给个star，谢谢！
功能  支持自适应大小 支持2个方向、4个方向、8个方向的摇动监听 支持摇动角度获取 可选回调模式 支持可摇动区域自定义 支持摇杆自定义 支持设置图片、色值、Shape图形  使用 &lt;kong.qingwei.rockerlibrary.RockerView android:id=&quot;@+id/rockerView_center&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:layout_centerHorizontal=&quot;true&quot; kongqw:areaBackground=&quot;#FF333333&quot; kongqw:rockerBackground=&quot;#FF987654&quot; kongqw:rockerRadius=&quot;15dp&quot; /&gt;  参数    参数 是否必须 描述     areaBackground 可选 可摇动区域的背景   rockerBackground 可选 摇杆的背景   rockerRadius 可选 摇杆半径    设置回调方式 setCallBackMode(CallBackMode mode)  参数
   回调方式 描述     CALL_BACK_MODE_MOVE 有移动就立刻回调   CALL_BACK_MODE_STATE_CHANGE 状态有变化的时候回调    监听摇动角度 返回角度的取值范围：[0°,360°)
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/%E6%95%B0%E6%8D%AE%E5%BD%92%E4%B8%80%E5%8C%96" class="link blue hover-black">
            Tag: 数据归一化
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/thinkgamer/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BD%92%E4%B8%80%E5%8C%96%E5%92%8C%E5%85%B6%E5%9C%A8sklearn%E4%B8%AD%E7%9A%84%E5%A4%84%E7%90%86/" class="link black dim">
        数据归一化和其在sklearn中的处理
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      一：数据归一化 数据归一化（标准化）处理是数据挖掘的一项基础工作，不同评价指标往往具有不同的量纲和量纲单位，这样的情况会影响到数据分析的结果，为了消除指标之间的量纲影响，需要进行数据标准化处理，以解决数据指标之间的可比性。原始数据经过数据标准化处理后，各指标处于同一数量级，适合进行综合对比评价。  归一化方法有两种形式，一种是把数变为（0，1）之间的小数，一种是把有量纲表达式变为无量纲表达式。在机器学习中我们更关注的把数据变到0～1之间，接下来我们讨论的也是第一种形式。
1）min-max标准化 min-max标准化也叫做离差标准化，是对原始数据的线性变换，使结果落到[0,1]区间，其对应的数学公式如下：
$$ X_{scale} = \frac{x-min}{max-min} $$
对应的python实现为
# x为数据 比如说 [1,2,1,3,2,4,1] def Normalization(x): return [(float(i)-min(x))/float(max(x)-min(x)) for i in x]  如果要将数据转换到[-1,1]之间，可以修改其数学公式为：
$$ X{scale} = \frac{x-x{mean}}{max-min} $$ x_mean 表示平均值。
对应的python实现为
import numpy as np # x为数据 比如说 [1,2,1,3,2,4,1] def Normalization(x): return [(float(i)-np.mean(x))/float(max(x)-min(x)) for i in x]  其中max为样本数据的最大值，min为样本数据的最小值。这种方法有个缺陷就是当有新数据加入时，可能导致max和min的变化，需要重新定义。
该标准化方法有一个缺点就是，如果数据中有一些偏离正常数据的异常点，就会导致标准化结果的不准确性。比如说一个公司员工（A，B，C，D）的薪水为6k,8k,7k,10w,这种情况下进行归一化对每个员工来讲都是不合理的。
当然还有一些其他的办法也能实现数据的标准化。
2）z-score标准化 z-score标准化也叫标准差标准化，代表的是分值偏离均值的程度，经过处理的数据符合标准正态分布，即均值为0，标准差为1。其转化函数为
$$ X_{scale} = \frac{x-\mu }{\sigma } $$
其中μ为所有样本数据的均值，σ为所有样本数据的标准差。
其对应的python实现为：
import numpy as np #x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] def z_score(x): return (x - np.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" class="link blue hover-black">
            Tag: 数据结构
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/thinkgamer/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E4%B9%8B%E9%93%BE%E8%A1%A8/" class="link black dim">
        数据结构算法之链表
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      链表面试总结，使用python实现，参考：https://www.cnblogs.com/lixiaohui-ambition/archive/2012/09/25/2703195.html 
#coding:utf-8 # 定义链表 class ListNode: def __init__(self): self.data = None self.pnext = None # 链表操作类 class ListNode_handle: def __init__(self): self.cur_node = None # 链表添加元素 def add(self,data): ln = ListNode() ln.data = data ln.pnext = self.cur_node self.cur_node = ln return ln # 打印链表 def prt(self,ln): while ln: print(ln.data,end=&quot; &quot;) ln = ln.pnext # 逆序输出 def _reverse(self,ln): _list = [] while ln: _list.append(ln.data) ln = ln.pnext ln_2 = ListNode() ln_h = ListNode_handle() for i in _list: ln_2 = ln_h.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/thinkgamer/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E4%B9%8B%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E5%BA%8F%E5%88%97/" class="link black dim">
        数据结构算法之合并两个有序序列
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      有序序列的合并，python实现。 
#coding:utf-8 a = [2,4,6,8,10] b = [3,5,7,9,11,13,15] c = [] def merge(a,b): i,j = 0,0 while i&lt;=len(a)-1 and j&lt;=len(b)-1: if a[i]&lt;b[j]: c.append(a[i]) i+=1 else: c.append(b[j]) j+=1 if i&lt;=len(a)-1: for m in a[i:]: c.append(m) if j&lt;=len(b)-1: for n in b[j:]: c.append(n) print(c) merge(a,b)  运行结果为：
[2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15]  
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/thinkgamer/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F/" class="link black dim">
        数据结构算法之排序
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      数据结构面试中经常会被问到篇排序相关的问题，那么这篇文章会研究下怎么用python来实现排序。
 冒泡排序 #coding：utf-8 # 冒泡排序 def maopao(): a = [2,1,4,3,9,5,6,8,7] for i in range(len(a)-1): for j in range(len(a)-1-i): if a[j]&gt;a[j+1]: temp = a[j] a[j] = a[j+1] a[j+1] = temp print(a) maopao()  结果为：
[1, 2, 3, 4, 5, 6, 7, 8, 9]  归并排序 # 归并排序 def merge(a,b): i,j = 0,0 c = [] while i&lt;=len(a)-1 and j&lt;=len(b)-1: if a[i]&lt;b[j]: c.append(a[i]) i+=1 else: c.append(b[j]) j+=1 if i&lt;=len(a)-1: for m in a[i:]: c.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/thinkgamer/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91/" class="link black dim">
        数据结构算法之二叉树
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      数据结构面试中经常会被问到篇二叉树相关的问题，那么这篇文章会研究下怎么用python来进行二叉树的构建和遍历。
 注意：py2中
print root.elem,  在py3中要换成
print (root.elem,end=&quot; &quot;)  # coding:utf-8 # 定义节点类 class Node: def __init__(self,elem = -1,): self.elem = elem self.left = None self.right = None # 定义二叉树 class Tree: def __init__(self): self.root = Node() self.myqu = [] # 添加节点 def add(self,elem): node = Node(elem) if self.root.elem == -1: # 判断如果是根节点 self.root = node self.myqu.append(self.root) else: treenode = self.myqu[0] if treenode.left == None: treenode.left = node self.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/%E6%96%87%E4%BB%B6%E5%AD%98%E5%8F%96" class="link blue hover-black">
            Tag: 文件存取
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2017-09-19-%E5%8D%B3%E6%8B%BF%E5%8D%B3%E7%94%A8android%E6%96%87%E4%BB%B6%E5%AD%98%E5%8F%96/" class="link black dim">
        即拿即用一Android文件存取
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      写文件 读文件 Assets文件读取 Bitmap保存 文件删除  写文件 /** * 写文件 * * @param filePath 文件绝对路径 * @param content 写入内容 * @return 写入是否成功 */ public static boolean writeFile(String filePath, String content) { FileOutputStream fileOutputStream = null; BufferedOutputStream bufferedOutputStream = null; try { File file = new File(filePath); if (file.createNewFile()) { fileOutputStream = new FileOutputStream(filePath); bufferedOutputStream = new BufferedOutputStream(fileOutputStream); bufferedOutputStream.write(content.getBytes(&quot;UTF-8&quot;)); bufferedOutputStream.flush(); return true; } } catch (IOException e) { e.printStackTrace(); } finally { if (null !
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D" class="link blue hover-black">
            Tag: 梯度下降
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/thinkgamer/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%A2%AF%E5%BA%A6%E7%AE%97%E6%B3%95%E4%B9%8B%E6%89%B9%E9%87%8F%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E5%92%8C%E5%B0%8F%E6%89%B9%E9%87%8F%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/" class="link black dim">
        梯度算法之批量梯度下降，随机梯度下降和小批量梯度下降
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      在机器学习领域，体梯度下降算法分为三种
 批量梯度下降算法（BGD，Batch gradient descent algorithm） 随机梯度下降算法（SGD，Stochastic gradient descent algorithm） 小批量梯度下降算法（MBGD，Mini-batch gradient descent algorithm）   批量梯度下降算法 BGD是最原始的梯度下降算法，每一次迭代使用全部的样本，即权重的迭代公式中(公式中用$\theta$代替$\theta_i$)， $$ \jmath (\theta _0,\theta _1,&hellip;,\theta n)=\sum{i=0}^{m}( h_\theta(x_0,x_1,&hellip;,x_n)-y_i )^2
$$ $$ \theta _i = \theta _i - \alpha \frac{\partial \jmath (\theta _1,\theta _2,&hellip;,\theta _n)}{\partial \theta _i} $$ $$ 公式(1) $$
这里的m代表所有的样本，表示从第一个样本遍历到最后一个样本。
特点：
 能达到全局最优解，易于并行实现 当样本数目很多时，训练过程缓慢  随机梯度下降算法 SGD的思想是更新每一个参数时都使用一个样本来进行更新，即公式（1）中m为1。每次更新参数都只使用一个样本，进行多次更新。这样在样本量很大的情况下，可能只用到其中的一部分样本就能得到最优解了。 但是，SGD伴随的一个问题是噪音较BGD要多，使得SGD并不是每次迭代都向着整体最优化方向。
特点： - 训练速度快 - 准确度下降，并不是最优解，不易于并行实现
小批量梯度下降算法 MBGD的算法思想就是在更新每一参数时都使用一部分样本来进行更新，也就是公式（1）中的m的值大于1小于所有样本的数量。
相对于随机梯度下降，Mini-batch梯度下降降低了收敛波动性，即降低了参数更新的方差，使得更新更加稳定。相对于批量梯度下降，其提高了每次学习的速度。并且其不用担心内存瓶颈从而可以利用矩阵运算进行高效计算。一般而言每次更新随机选择[50,256]个样本进行学习，但是也要根据具体问题而选择，实践中可以进行多次试验，选择一个更新速度与更次次数都较适合的样本数。mini-batch梯度下降可以保证收敛性，常用于神经网络中。
补充 在样本量较小的情况下，可以使用批量梯度下降算法，样本量较大的情况或者线上，可以使用随机梯度下降算法或者小批量梯度下降算法。
在机器学习中的无约束优化算法，除了梯度下降以外，还有前面提到的最小二乘法，此外还有牛顿法和拟牛顿法。
梯度下降法和最小二乘法相比，梯度下降法需要选择步长，而最小二乘法不需要。梯度下降法是迭代求解，最小二乘法是计算解析解。如果样本量不算很大，且存在解析解，最小二乘法比起梯度下降法要有优势，计算速度很快。但是如果样本量很大，用最小二乘法由于需要求一个超级大的逆矩阵，这时就很难或者很慢才能求解解析解了，使用迭代的梯度下降法比较有优势。
梯度下降法和牛顿法/拟牛顿法相比，两者都是迭代求解，不过梯度下降法是梯度求解，而牛顿法/拟牛顿法是用二阶的海森矩阵的逆矩阵或伪逆矩阵求解。相对而言，使用牛顿法/拟牛顿法收敛更快。但是每次迭代的时间比梯度下降法长。
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/thinkgamer/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%A2%AF%E5%BA%A6%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A2%AF%E5%BA%A6%E4%B8%8A%E5%8D%87%E5%92%8C%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/" class="link black dim">
        梯度算法之梯度上升和梯度下降
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      第一次看见随机梯度上升算法是看《机器学习实战》这本书，当时也是一知半解，只是大概知道和高等数学中的函数求导有一定的关系。下边我们就好好研究下随机梯度上升（下降）和梯度上升（下降）。 
高数中的导数 设导数 y = f(x) 在 $ x_0 $的某个邻域内有定义，当自变量从 $ x0 $ 变成 $$ x{0} + \Delta x $$ 函数y=f(x)的增量
$$ \Delta y = f(x_0 + \Delta x) - f(x_0) $$ 与自变量的增量 $ \Delta x $ 之比：
$$ \frac{ \Delta y }{ \Delta x } = \frac{ f(x_0 + \Delta x)-f(x0) }{ \Delta x } $$ 称为f(x)的平均变化率。 如 $ \Delta x \rightarrow 0 $ 平均变化率的极限 $$ \lim{\Delta x \rightarrow 0} \frac{ \Delta y }{ \Delta x } = \lim_{\Delta x \rightarrow 0} \frac{ f(x_0 + \Delta x)-f(x_0) }{ \Delta x } $$ 存在，则称极限值为f(x)在$ x_0 $ 处的导数，并说f(x)在$ x_0 $ 处可导或有导数。当平均变化率极限不存在时，就说f(x)在 $ x_0 $ 处不可导或没有导数。
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/%E6%AD%A3%E5%BC%A6%E6%B3%A2" class="link blue hover-black">
            Tag: 正弦波
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-29-android%E8%BE%93%E5%87%BA%E6%AD%A3%E5%BC%A6%E6%B3%A2%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7-%E5%B7%A6%E5%8F%B3%E5%A3%B0%E9%81%93%E5%AF%B9%E7%A7%B0/" class="link black dim">
        Android输出正弦波音频信号(左右声道对称)
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
需求：左右声道分别输出不同的音频数据，波形要是一个正弦波，左右声道还要对称！ 对硬件不是很了解，说是要通过音波避障。
效果图 之前已经介绍了如何在左右声道输出不同的音频数据。 那么这里主要介绍如何模拟出波形是正弦波的音频数据。
模拟正弦波 /** * 模拟正弦波音频数据 * @param isLeft 左右声道 * @return 音频数据 */ private short[] initData(boolean isLeft) { double phase = 0.0; int amp = 10000; short[] data = new short[bufferSize]; double phaseIncrement = (2 * Math.PI * mFrequency) / mSampleRateInHz; for (int i = 0; i &lt; bufferSize; i++) { if (isLeft) { data[i] = (short) (amp * Math.sin(phase)); } else { data[i] = (short) (-amp * Math.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83" class="link blue hover-black">
            Tag: 正态分布
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/thinkgamer/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90%E4%B9%8B%E7%90%86%E8%AE%BA%E7%AF%87/" class="link black dim">
        回归分析之理论篇
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      2015年的机器学习博客其实都是看《机器学习实战》这本书时学到的，说实话当时也是知其然，不知其所以然，以至于对其理解不深刻，好多细节和理论知识都搞的是乱七八糟，自从工作之后再去看一个算法，思考的比之前多了点，查看资料也比之前多了点，生怕理解错误，影响其他人，当然在理解的程度上还是不够深刻，这也是一个学习的过程吧，记录一下，欢迎指正。
CSDN链接：点击阅读 
一：一些名词定义 1）指数分布族 指数分布族是指可以表示为指数形式的概率分布。 $$ f_X(x\mid\theta) = h(x) \exp \left (\eta(\theta) \cdot T(x) -A(\theta)\right ) $$ 其中，η为自然参数(nature parameter)，T(x)是充分统计量（sufficient statistic）。当参数A，h，T都固定以后，就定义了一个以η为参数的函数族。
伯努利分布与高斯分布是两个典型的指数分布族
伯努利分布 又名两点分布或者0-1分布，是一个离散型概率分布。假设1的概率为p，0的概率为q，则 其概率质量函数为：
{\displaystyle f_{X}(x)=p^{x}(1-p)^{1-x}=\left\{{\begin{matrix}p&amp;{\mbox{if }}x=1,\\q\ &amp;{\mbox{if }}x=0.\\\end{matrix}}\right.}  其期望值为： $$ {\displaystyle \operatorname {E} [X]=\sum {i=0}^{1}x{i}f_{X}(x)=0+p=p} $$
其方差为： $$ {\displaystyle \operatorname {var} [X]=\sum {i=0}^{1}(x{i}-E[X])^{2}f_{X}(x)=(0-p)^{2}(1-p)+(1-p)^{2}p=p(1-p)=pq} $$
正态分布(高斯分布) 若随机变量X服从一个位置参数为 ${\displaystyle \mu }$ 、尺度参数为 ${\displaystyle \sigma } $ 的概率分布，记为： $$ X \sim N(\mu,\sigma^2), $$
其概率密度函数为:
f(x) = {1 \over \sigma\sqrt{2\pi} }\,e^{- {{(x-\mu )^2 \over 2\sigma^2}}}  正态分布的数学期望值或期望值$ {\displaystyle \mu } $ 等于位置参数，决定了分布的位置；其方差 $ {\displaystyle \sigma ^{2}} $ 的开平方或标准差$ {\displaystyle \sigma }$ 等于尺度参数，决定了分布的幅度。
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/%E7%8E%AF%E4%BF%A1" class="link blue hover-black">
            Tag: 环信
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-22-%E7%8E%AF%E4%BF%A1%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E5%9C%A8android%E5%B9%B3%E5%8F%B0%E7%9A%84%E9%83%A8%E7%BD%B2/" class="link black dim">
        环信即时通讯在Android平台的部署
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
官网 环信
下载SDK
创建一个工程 如果想要封装性好一点，也可以在工程里再创建一个环信的Library，然后将SDK里的jar和.so，都导入到工程
清单文件 下面是环信Library库里面的清单文件，包含了权限的设置、APPKEY的设置和服务的声明等。
&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;……&quot;&gt; &lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.GET_TASKS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.USE_CREDENTIALS&quot; /&gt; &lt;uses-permission android:name=&quot;com.android.launcher.permission.READ_SETTINGS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.BROADCAST_STICKY&quot; /&gt; &lt;uses-permission android:name=&quot;android.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/%E8%93%9D%E7%89%99" class="link blue hover-black">
            Tag: 蓝牙
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2017-03-16-android-%E8%93%9D%E7%89%99%E9%80%9A%E4%BF%A1androidbluetoothmanager/" class="link black dim">
        Android蓝牙通信——AndroidBluetoothManager
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN

To get a Git project into your build:
Step 1. Add the JitPack repository to your build file
Add it in your root build.gradle at the end of repositories:
allprojects { repositories { ... maven { url 'https://jitpack.io' } } }  Step 2. Add the dependency
dependencies { compile 'com.github.kongqw:AndroidBluetoothManager:1.0.0' }  AndroidBluetoothManager
效果图 PNG
GIF
基础功能 添加权限 &lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot; /&gt; &lt;uses-permission android:name=&quot;android.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/%E8%93%9D%E7%89%99%E9%80%9A%E4%BF%A1" class="link blue hover-black">
            Tag: 蓝牙通信
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-02-android%E8%93%9D%E7%89%99%E9%80%9A%E4%BF%A1/" class="link black dim">
        Android蓝牙通信
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
Android蓝牙通信 效果图  两台真机设备
 源码 GitHub
 关于蓝牙的开关控制，设置设备可见、搜索附近的蓝牙设备，已经封装到了 BluetoothManager 类
 关于设备的连接、通信。已经封装到了 BluetoothService 类
  注：下面的全部内容，主要是思路，具体的可以参考上面的源码，如果对你有帮助记得给个赞哦。
权限 &lt;!-- 蓝牙的权限 --&gt; &lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot; /&gt;  蓝牙的打开与关闭 开启蓝牙 mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); /** * 开启蓝牙 */ public void openBluetooth() { try { mBluetoothAdapter.enable(); } catch (Exception e) { e.printStackTrace(); } }  关闭蓝牙 mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); /** * 关闭蓝牙 */ public void closeBluetooth() { try { mBluetoothAdapter.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/%E8%AF%AD%E9%9F%B3" class="link blue hover-black">
            Tag: 语音
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-16-%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E%E4%B8%8E%E7%81%B5%E4%BA%91%E8%AF%AD%E9%9F%B3%E5%AF%B9%E6%AF%94/" class="link black dim">
        科大讯飞与灵云语音对比
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
对比     科大讯飞 灵云语音     语音能力 语音合成、语音识别、语义、命令词、唤醒 没有独立的唤醒功能，需要使用命令词实现唤醒。   初始化 我们购买完离线资源包以后，集成到工程里，就可以保持在离线环境下使用 即使使用离线语音能力，第一次使用的时候，也必须要联网，激活离线语音能力以后，才可以使用   网络请求 各种请求均异步操作，不会阻塞线程。 在线文字语义识别，是同步操作，其它是异步操作过程。（同步操作时间超过5秒会导致Android终端抛出NAR异常导致崩溃）   语义 场景定义灵活，开发者可在后台自定义，通过申请的方式，可以开通自定义场景，目前免费开放。语义解析失败，可以将语音转文字。 场景的定义需要联系客服人员开通，自定义场景需要付费（说是一般一个场景2万元）。语义解析失败不能转成文字   语音唤醒 支持（官方自称低功耗） 实际没有唤醒功能，是使用离线命令词的方式模拟出了唤醒，效果不理想。尚未发现可以发现可以设置门限值等常用参数的API。   命令词识别 离线使用BNF语法，在线使用ABNF语法，语法可以使用占位符等等的操作符 离线和在线都使用JSGF语法。    灵云唤醒机制 用命令词的方式实现唤醒，用唤醒词做命令词，做好标识，然后循环开启命令词识别，当识别到唤醒的命令词的时候，视为被唤醒了。
个人认为这种方式实现唤醒效果不好，原因如下：
 录音都有前端点超时时间和后端点超时时间，这样一来，即使我们准确的说出唤醒词，也要在说完唤醒词以后，保证在后端点时间内不再有声音录入，才能提高被唤醒的几率。
 唤醒不是即时的，即使我们准确的说出唤醒词，并保持不再有声音录入，也要至少等待后端点时间过去，录音结束以后，才会识别（被唤醒）。
 这种方式的唤醒其实就是在进行语音识别，如果一直开启唤醒，消耗性能，耗电。
   前端点超时时间: 在前置端点时间内没有有效的声音录入，表示此次录音无效，结束录音. 后端点超时时间: 录音结束以后，在后置端点时间内没有再录入有效声音，表示录音完成，结束录音。  总结 科大讯飞语音方面更灵活，更好用。
灵云语音，在人工智能方面提供的技术更全面（还包括图像识别，手写识别，人脸识别，指纹识别、机器翻译等），偏定制（智能家居、车载系统、机器人等智能设备的定制）。
单从语音能力角度来比较，讯飞更好。
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-16-%E7%81%B5%E4%BA%91%E8%AF%AD%E9%9F%B3%E5%94%A4%E9%86%92/" class="link black dim">
        灵云语音唤醒
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
       转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
严格来讲，灵云没有语音唤醒功能，但是通过命令词的方式可以实现
实现方式 用命令词的方式实现唤醒，用唤醒词做命令词，做好标识，然后循环开启命令词识别，当识别到唤醒的命令词的时候，视为被唤醒了。
我个人认为这种方式实现唤醒意义不大，所以没有做demo，原因如下：
 录音都有前端点超时时间和后端点超时时间,这样一来，即使我们准确的说出唤醒词，也要在说完唤醒词以后，保证在后端点时间内不再有声音录入，才能提高被唤醒的几率。
 唤醒不是即时的，即使我们准确的说出唤醒词，并保持不再有声音录入，也要至少等待后端点时间过去，录音结束以后，才会识别（被唤醒）。
 这种方式的唤醒其实就是在进行语音识别，如果一直开启唤醒，消耗性能，耗电。
   前端点超时时间: 在前置端点时间内没有有效的声音录入，表示此次录音无效，结束录音. 后端点超时时间: 录音结束以后，在后置端点时间内没有再录入有效声音，表示录音完成，结束录音。  
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-15-%E7%81%B5%E4%BA%91%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/" class="link black dim">
        灵云语音识别
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
源码 GitHub
在线语音识别 SDK下载 灵云SDK下载
SDK集成 下载SDK以后，将jar和so导入工程
权限 &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt;  封装 灵云配置类 package kong.qingwei.kqwhcidemo; /** * Created by kqw on 2016/8/12. * 灵云配置信息 */ public final class ConfigUtil { /** * 灵云APP_KEY */ public static final String APP_KEY = &quot;3d5d5466&quot;; /** * 开发者密钥 */ public static final String DEVELOPER_KEY = &quot;eca643ff7b3c758745d7cf516e808d34&quot;; /** * 灵云云服务的接口地址 */ public static final String CLOUD_URL = &quot;test.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-15-%E7%81%B5%E4%BA%91%E8%AF%AD%E4%B9%89%E7%90%86%E8%A7%A3/" class="link black dim">
        灵云语义理解
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
效果图 源码 GitHub
SDK下载 灵云SDK下载
SDK集成 下载SDK以后，将jar和so导入工程
权限 &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;  封装 灵云配置类 package kong.qingwei.kqwhcidemo; /** * Created by kqw on 2016/8/12. * 灵云配置信息 */ public final class ConfigUtil { /** * 灵云APP_KEY */ public static final String APP_KEY = &quot;3d5d5466&quot;; /** * 开发者密钥 */ public static final String DEVELOPER_KEY = &quot;eca643ff7b3c758745d7cf516e808d34&quot;; /** * 灵云云服务的接口地址 */ public static final String CLOUD_URL = &quot;test.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-12-%E7%81%B5%E4%BA%91%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90/" class="link black dim">
        灵云语音合成
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
注册 官网
注册比较简单，就不做过多介绍了，注册万应用以后，在后台创建自己的应用，创建完应用以后需要给应用开通对应的语音能力。
集成 下载灵云SDK
如果使用在线功能，下载对应的SDK，里面有jar包和so，就可以满足需求了。如果要使用离线的语音功能，还需要下载灵云资源文件
源码 GitHub
灵云在线语音合成 权限 &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;  配置类 package kong.qingwei.kqwhcittsdemo; /** * Created by kqw on 2016/8/12. * 灵云配置信息 */ public final class ConfigUtil { /** * 灵云APP_KEY */ public static final String APP_KEY = &quot;填入自己的APP KEY&quot;; /** * 开发者密钥 */ public static final String DEVELOPER_KEY = &quot;填入自己的DEVELOPER KEY&quot;; /** * 灵云云服务的接口地址 */ public static final String CLOUD_URL = &quot;test.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2015-08-30-%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E%E7%A6%BB%E7%BA%BF%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90%E8%AF%AD%E8%AE%B0/" class="link black dim">
        科大讯飞离线语音合成（语记）
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
离线语音合成（语记） 讯飞的语音合成有三种方式
 在线语音合成（免费） 离线使用语记语音合成（免费，需要本地装一个语记App并且下载离线资源） 使用讯飞离线语音包（付费）  这里使用语记实现离线语音合成
效果图 源码 下载地址（Android Studio工程）：http://download.csdn.net/detail/q4878802/9063593
说明 使用语记实现离线语音合成和在线语音合成的步骤非常相似，下载SDK的方式是一样的，一样是选择在线语音合成，只不过是使用离线引擎就可以借用语音合成语音了。
在线语音合成地址：http://blog.csdn.net/q4878802/article/details/48092495
下面说说和在线语音合成不用的地方
1. 下载并安装语记，下载离线资源 离线语音听写的文章里有介绍，地址： http://blog.csdn.net/q4878802/article/details/47834601
2. 网络权限就可以删掉了，本地合成不需要联网，但是获取网络状态的权限一定要有。 &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;  3. 将识别引擎改为本地引擎 // 引擎类型 本地 mTts.setParameter(SpeechConstant.ENGINE_TYPE, SpeechConstant.TYPE_LOCAL);  4. 在Application初始化的类里把引擎模式设置的参数注释掉 // param.append(&quot;,&quot;); // param.append(SpeechConstant.ENGINE_MODE + &quot;=&quot; + SpeechConstant.MODE_MSC);  SpeechConstant.MODE_MSC 参数意思是使用离线包资源，如果离线包资源找不到会走网络识别，如果设置这种模式是不会使用语记（语音+）的如果使用离线包，就需要这条参数。
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2015-08-30-%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E%E7%A6%BB%E7%BA%BF%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90/" class="link black dim">
        科大讯飞离线语音合成
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
离线语音合成（离线资源包） 讯飞的语音合成有三种方式
 在线语音合成（免费） 离线使用语记语音合成（免费，需要本地装一个语记App并且下载离线资源） 使用讯飞离线语音包（付费）  这里使用离线资源包实现离线语音合成，因为正式版是要付费的，所以这里使用试用的离线包（35天试用期、3个装机量）。
效果图 源码 下载地址（Android Studio工程）：http://download.csdn.net/detail/q4878802/9063779
开通服务，下载SDK 之前已经介绍过，地址：http://blog.csdn.net/q4878802/article/details/47762169#t8
将SDK里提供的jar包、so库、离线资源都拷贝到我们的工程（Android Studio工程） 创建的工程默认可能没有jniLibs和assets目录，我们要自己在main下创建这两个目录
初始化 在清单文件中application标签下添加name属性
android:name=&quot;.InitApplication&quot;  初始化
package com.example.kongqw.kqwspeechcompounddemo; import android.app.Application; import android.widget.Toast; import com.iflytek.cloud.SpeechConstant; import com.iflytek.cloud.SpeechUtility; /** * Created by kongqw on 2015/8/29. */ public class InitApplication extends Application { @Override public void onCreate() { Toast.makeText(this, &quot;InitApplication&quot;, Toast.LENGTH_LONG).show(); // 应用程序入口处调用,避免手机内存过小,杀死后台进程后通过历史intent进入Activity造成SpeechUtility对象为null // 如在Application中调用初始化，需要在Mainifest中注册该Applicaiton // 注意：此接口在非主进程调用会返回null对象，如需在非主进程使用语音功能，请增加参数：SpeechConstant.FORCE_LOGIN+&quot;=true&quot; // 参数间使用“,”分隔。 // 设置你申请的应用appid StringBuffer param = new StringBuffer(); param.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2015-08-30-%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E%E8%AF%AD%E4%B9%89%E8%AF%86%E5%88%AB/" class="link black dim">
        科大讯飞语义识别
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
效果图 源码 下载地址（Android Studio工程）：http://download.csdn.net/detail/q4878802/9064463
语义测试接口 地址：http://osp.voicecloud.cn/index.php/default/quicktest/index
开通服务，下载SDK 之前已经介绍过，地址：http://blog.csdn.net/q4878802/article/details/47762169#t8
这里说一下，进入到SDK的下载界面，你发现找不到语义的服务，而在我们开通服务的时候都是默认就帮我们把语义的服务开启了，可能是因为语义是只能用网络的，没有本地的资源，所以只要选择一个在线的功能，使用的jar包应该都是一样的，为什么没有直接下载语义的SDK我也不是很清楚，但是都可以用。
说明 之前的工程都是在Eclipse下演示的，随着Android Studio的普及，我这里也开始使用Android Studio写Demo，虽然导入jar包和so库的过程可能不太一样，但是整体的流程是一样的。
将jar包和so库导入Android Studio工程  将jar包copy到libs目录下
在main目录下创建jniLibs目录，将so文件copy过来
 初始化  在清单文件中application标签下添加name属性
 android:name=&quot;.InitApplication&quot;  初始化
package com.example.kongqw.kqwunderstanddemo; import android.app.Application; import android.widget.Toast; import com.iflytek.cloud.SpeechConstant; import com.iflytek.cloud.SpeechUtility; /** * Created by kongqw on 2015/8/29. */ public class InitApplication extends Application { @Override public void onCreate() { Toast.makeText(this, &quot;InitApplication&quot;, Toast.LENGTH_LONG).show(); // 应用程序入口处调用,避免手机内存过小,杀死后台进程后通过历史intent进入Activity造成SpeechUtility对象为null // 如在Application中调用初始化，需要在Mainifest中注册该Applicaiton // 注意：此接口在非主进程调用会返回null对象，如需在非主进程使用语音功能，请增加参数：SpeechConstant.FORCE_LOGIN+&quot;=true&quot; // 参数间使用“,”分隔。 // 设置你申请的应用appid StringBuffer param = new StringBuffer(); param.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2015-08-29-%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90/" class="link black dim">
        科大讯飞在线语音合成
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
效果图 源码 下载地址（Android Studio工程）：http://download.csdn.net/detail/q4878802/9062261
下载SDK 1. 选择服务 2. 选择平台 3. 选择应用 4. 下载SDK 说明 之前的工程都是在Eclipse下演示的，随着Android Studio的普及，我这里也开始使用Android Studio写Demo，虽然细节导入jar包和so库的过程可能不太一样，但是整体的流程是一样的。
将jar包和so库导入Android Studio工程 将jar包copy到libs目录下 在main目录下创建jniLibs目录，将so文件copy过来
添加网络权限 &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;  初始化 在清单文件中application标签下添加name属性
android:name=&quot;.InitApplication&quot;  初始化
package com.example.kongqw.kqwspeechcompounddemo; import android.app.Application; import android.widget.Toast; import com.iflytek.cloud.SpeechConstant; import com.iflytek.cloud.SpeechUtility; /** * Created by kongqw on 2015/8/29. */ public class InitApplication extends Application { @Override public void onCreate() { Toast.makeText(this, &quot;InitApplication&quot;, Toast.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2015-08-21-%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/" class="link black dim">
        科大讯飞语音识别
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
离线语音识别（语记） 效果图 源码 下载地址：http://download.csdn.net/detail/q4878802/9032149
下载语记并安装离线资源 集成 初始化 在清单文件中application标签下添加
android:name=&quot;InitKqwSpeech&quot;  初始化
package com.example.kqwlocalspeechdemo; import com.iflytek.cloud.SpeechConstant; import com.iflytek.cloud.SpeechUtility; import android.app.Application; public class InitKqwSpeech extends Application { @Override public void onCreate() { // 应用程序入口处调用,避免手机内存过小,杀死后台进程后通过历史intent进入Activity造成SpeechUtility对象为null // 如在Application中调用初始化，需要在Mainifest中注册该Applicaiton // 注意：此接口在非主进程调用会返回null对象，如需在非主进程使用语音功能，请增加参数：SpeechConstant.FORCE_LOGIN+&quot;=true&quot; // 参数间使用“,”分隔。 // 设置你申请的应用appid StringBuffer param = new StringBuffer(); param.append(&quot;appid=55d33f09&quot;); param.append(&quot;,&quot;); param.append(SpeechConstant.ENGINE_MODE + &quot;=&quot; + SpeechConstant.MODE_MSC); // param.append(&quot;,&quot;); // param.append(SpeechConstant.FORCE_LOGIN + &quot;=true&quot;); SpeechUtility.createUtility(InitKqwSpeech.this, param.toString()); super.onCreate(); } }  语音听写工具类 package com.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2015-08-20-%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E%E7%A6%BB%E7%BA%BF%E5%91%BD%E4%BB%A4%E8%AF%8D&#43;%E8%AF%AD%E4%B9%89%E8%AF%86%E5%88%AB/" class="link black dim">
        科大讯飞离线命令词&#43;语义识别
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
       转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
离线命令词+语义识别 意思就是先走离线命令词识别，如果离线命令词识别没有识别到结果，那么就再走语义接口，如果已开通对应场景，则转为语义，如果没有开通对应场景，则将语音转为文字
效果图  说的话满足本地构建的语法&mdash;-离线命令词识别   说的话离线命令词无法识别，走语义识别并且满足语义场景&mdash;-将语音转为语义   说话既不满足离线命令词识别也不满足语义开通的场景&mdash;-将语音转为文字  程序和离线命令词识别基本一样
离线命令词识别地址：http://blog.csdn.net/q4878802/article/details/47780485
只要改一个参数，将识别引擎改为混合模式即可
mAsr.setParameter(SpeechConstant.ENGINE_TYPE, SpeechConstant.TYPE_MIX);  因为使用的混合模式，当本地命令词没有识别到结果的时候会走在线语义（语义只有在线），所以，我们必须要先开通语义服务
程序流程 最后  如果你直接用我的Demo，我用的是测试版的离线包，只有35天的试用期，而且装机量只有3个，如果大家都用，很可能是不能正常运行的 如果是参考我的demo自己写一个，千万不要忘记替换appid和资源文件。  
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2015-08-19-%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E%E8%AF%AD%E9%9F%B3%E5%94%A4%E9%86%92/" class="link black dim">
        科大讯飞语音唤醒
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
语音唤醒 唤醒功能，顾名思义，通过语音，唤醒服务，做我们想做的事情。
效果图  开启应用后说讯飞语音或者讯飞语点唤醒
 源码下载 地址：http://download.csdn.net/detail/q4878802/9023213
步骤 1. 创建应用，开通服务 地址：http://blog.csdn.net/q4878802/article/details/47762169
2. 下载SDK 我们要使用的是讯飞的付费功能，选择唤醒服务，点击下载以后，会提示没有购买。点击“购买服务”
点击购买一会看到付费情况，有项目需要，就必须购买，我们写Demo，讯飞给提供了体验版的SDK，和正式版的没有功能上的区别，但是只能试用35天，装机量只有3个，唤醒词不能改，只有“讯飞语音”和“讯飞语点”两个唤醒词。
3. 解压SDK assets目录下是一些图片资源文件 doc目录下是一些开发文档 libs目录下是一些jar包和so库 res目录下是语音的资源文件，非常重要 sample目录下是Demo
开发步骤 1. 添加权限 这里用到的唤醒功能不是所有的权限都用到的，具体用到了哪些权限，可以看上面的链接，用到哪写权限就加哪些权限，这个为了快速方便测试，把讯飞用到的权限都加上了。
&lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.CHANGE_NETWORK_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;  2. 初始化appid 我是将appid的初始化放在的Applicaiton下，具体可以下载源码
// 应用程序入口处调用,避免手机内存过小,杀死后台进程后通过历史intent进入Activity造成SpeechUtility对象为null // 如在Application中调用初始化，需要在Mainifest中注册该Applicaiton // 注意：此接口在非主进程调用会返回null对象，如需在非主进程使用语音功能，请增加参数：SpeechConstant.FORCE_LOGIN+&quot;=true&quot; // 参数间使用“,”分隔。 // 设置你申请的应用appid StringBuffer param = new StringBuffer(); param.
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2015-08-19-%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E%E7%A6%BB%E7%BA%BF%E5%91%BD%E4%BB%A4%E8%AF%8D%E8%AF%86%E5%88%AB/" class="link black dim">
        科大讯飞离线命令词识别
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
效果图  示例源码  地址：http://download.csdn.net/detail/q4878802/9023825
步骤： 1. 下载SDK 前面文章有，就不在复述了。这里要选择离线命令词的服务以后，重新加载，因为需要下载离线命令词识别的资源文件
地址：http://blog.csdn.net/q4878802/article/details/47762169
2. 集成方法 前面文章有，就不在复述了。
地址：http://blog.csdn.net/q4878802/article/details/47778629
3. 正题，开始集成 1. 添加权限 这里用到的唤醒功能不是所有的权限都用到的，具体用到了哪些权限，可以看上面的链接，用到哪写权限就加哪些权限，这个为了快速方便测试，把讯飞用到的权限都加上了。
&lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.CHANGE_NETWORK_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;  2. 初始化appid 我是将appid的初始化放在的Applicaiton下，具体可以下载源码
// 应用程序入口处调用,避免手机内存过小,杀死后台进程后通过历史intent进入Activity造成SpeechUtility对象为null // 如在Application中调用初始化，需要在Mainifest中注册该Applicaiton // 注意：此接口在非主进程调用会返回null对象，如需在非主进程使用语音功能，请增加参数：SpeechConstant.FORCE_LOGIN+&quot;=true&quot; // 参数间使用“,”分隔。 // 设置你申请的应用appid StringBuffer param = new StringBuffer(); param.
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/%E8%B7%9D%E7%A6%BB%E8%AE%A1%E7%AE%97" class="link blue hover-black">
            Tag: 距离计算
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/thinkgamer/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%87%A0%E7%A7%8D%E8%B7%9D%E7%A6%BB%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F%E5%9C%A8%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/" class="link black dim">
        几种距离计算公式在数据挖掘中的应用场景分析
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      本文涉及以下几种距离计算公式的分析，参考资料为《面向程序员的数据挖掘指南》
 曼哈顿距离 欧几里得距离 闵可夫斯基距离 皮尔逊相关系数 余弦相似度   之前整理过一篇关于距离相关的文章：[机器学习算法中的距离和相似性计算公式，分析以及python实现]()
闵可夫斯基距离 两个n维变量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的闵可夫斯基距离定义为： $$ \sqrt[p]{ \sum{k=1}^{n} \left | x{1k}-x_{2k} \right |^p} $$
其中p是一个变参数。
当p=1时，就是曼哈顿距离
当p=2时，就是欧氏距离
当p→∞时，就是切比雪夫距离
根据变参数的不同，闵氏距离可以表示一类的距离。
p值越大，单个维度的差值大小会对整体距离有更大的影响
曼哈顿距离／欧几里得距离的瑕疵 在《面向程序员的数据挖掘指南》中给出了这样一组样例数据, 下图为一个在线音乐网站的的用户评分情况，用户可以用1-5星来评价一个乐队，下边是8位用户对8个乐队的评价： 表中的横线表示用户没有对乐队进行评价，我们在计算两个用户的距离时，只采用他们都评价过的乐队。
现在来求Angelica和Bill的距离，因为他们共同评分过的乐队有5个，所以使用其对该5个乐队的评分进行曼哈顿距离的计算为：
Dis_1 = |3.5-2| + |2-3.5| + |5-2| + |1.5-3.5| + |2-3| = 9  同样使用欧式距离计算为：
Dis_2 = sqrt( (3.5-2)^2 + (2-3.5)^2 + (5-2)^2 + (1.5-3.5)^2 + (2-3)^2 ) = 4.3  当对Angelica和Bill，Bill和Chan进行距离对比时，由于两者的共同评分过的乐队均为5，数据都在一个5维空间里，是公平的，如果现在要计算Angelica和Hailey与Bill的距离时，会发现，Angelica与Bill共同评分的有5个乐队，Hailey与Bill共同评分的有3个乐队，也就是说两者数据一个在5维空间里，一个在三维空间里，这样明显是不公平的。这将会对我们进行计算时产生不好的影响，所以曼哈顿距离和欧几里得距离在数据完整的情况下效果最好。
用户问题／皮尔逊相关系数／分数膨胀 现象——用户问题 仔细观察用户对乐队的评分数据，可以发现每个用户的评分标准不同：
 Bill没有打出极端的分数，都在2-4分之间 Jordyn似乎喜欢所有的乐队，打分都在4-5之间 Hailey是一个有趣的人，他的评分不是1就是4  那么如何比较这些用户呢？比如说Hailey的4分是相当于Jordyn的4分还是5分呢？我觉得更接近5分，这样一来，就影响推荐系统的准确性了！
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/thinkgamer/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/machinglearning%E4%B8%AD%E7%9A%84%E8%B7%9D%E7%A6%BB%E5%92%8C%E7%9B%B8%E4%BC%BC%E6%80%A7%E8%AE%A1%E7%AE%97%E4%BB%A5%E5%8F%8Apython%E5%AE%9E%E7%8E%B0/" class="link black dim">
        MachingLearning中的距离和相似性计算以及python实现
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      前言 写这篇文章的目的不是说摘抄网上其他人的总结，刚才最近在看这方面的东西，为了让自己能够实际的去感受下每种求距离公式的差别，然后用python进行具体实现。  在机器学习中，经常要用到距离和相似性的计算公式，我么要常计算个体之间的差异大小，继而评价个人之间的差异性和相似性，最常见的就是数据分析中的相关分析，数据挖掘中的分类和聚类算法。如利用k-means进行聚类时，判断个体所属的类别，要利用距离计算公式计算个体到簇心的距离，如利用KNN进行分类时，计算个体与已知类别之间的相似性，从而判断个体所属的类别等。
文章编辑的过程中或许存在一个错误或者不合理的地方，欢迎指正。
参考：http://www.cnblogs.com/heaad/archive/2011/03/08/1977733.html
推荐：https://my.oschina.net/hunglish/blog/787596
欧氏距离 也称欧几里得距离，是指在m维空间中两个点之间的真实距离。欧式距离在ML中使用的范围比较广，也比较通用，就比如说利用k-Means对二维平面内的数据点进行聚类，对魔都房价的聚类分析（price/m^2 与平均房价）等。
二维空间的欧氏距离 二维平面上两点a(x1,y1)与b(x2,y2)间的欧氏距离
$$ d12 =\sqrt{(x{1}-x{2})^2+(y{1}-y{2})^2} $$ python 实现为：
# coding: utf-8 from numpy import * def twoPointDistance(a,b): d = sqrt( (a[0]-b[0])**2 + (a[1]-b[1])**2 ) return d print 'a,b 二维距离为：',twoPointDistance((1,1),(2,2))  三维空间的欧氏距离 三维空间两点a(x1,y1,z1)与b(x2,y2,z2)间的欧氏距离
$$d12 =\sqrt{(x{1}-x{2})^2+(y{1}-y{2})^2+(z{1}-z{2})^2}$$ python 实现为：
def threePointDistance(a,b): d = sqrt( (a[0]-b[0])**2 + (a[1]-b[1])**2 + (a[2]-b[2])**2 ) return d print 'a,b 三维距离为：',threePointDistance((1,1,1),(2,2,2))  多维空间的欧氏距离 两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的欧氏距离
$$ \sqrt{\sum{n}^{k=1}(x{1k}-x_{2k})^2 } $$ python 实现为：
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/%E9%9A%8F%E6%89%8B%E8%AE%B0" class="link blue hover-black">
            Tag: 随手记
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/thinkgamer/%E9%9A%8F%E6%89%8B%E8%AE%B0/%E4%B8%80%E5%88%87%E7%9A%84%E9%97%B9%E9%97%B9%E5%93%84%E5%93%84%E5%8F%AA%E6%98%AF%E4%BB%96%E5%9C%A8%E6%B0%B4%E5%B8%98%E6%B4%9E%E8%BA%B2%E9%81%BF%E9%A3%8E%E6%B2%99%E9%82%A3%E6%99%9A%E5%81%9A%E7%9A%84%E4%B8%80%E4%B8%AA%E6%A2%A6/" class="link black dim">
        一切的闹闹哄哄，只是他在水帘洞躲避风沙那晚做的一个梦
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      送同学走之后，我在路边默默的站了有五分钟，突然觉得我无处可去，有一种深入骨髓的悲哀和无奈，然后我就想起了一个命题，“如今的你，何去何从！”我不知道为什么会突然想到这样一个命题，或许是我们每个人都是至尊宝吧。其实每个人对《大话》的理解都是有所不同的，同样的人在不同的时期认识也会有偏差，就好比我第一次看的时候，笑得腹背抽筋，呲牙咧嘴，第二次看的时候，笑得少了，想的多了，过后便什么感觉也没有了，第三次看得时候，忽然觉得不知道是该哭还是该笑，笑得时候太牵强，哭得时候太尴尬。第四次便是这一次，看完之后觉得有一种无可奈何的悲哀。
  对《大话》的解读 有人说这是一部烂片，也有人说这是一部经典，有人说这是对西游文化的过度消费，有人说这是一代人的反思与成长，有人说阴差阳错的蝴蝶效应，让一个年代的人支撑起了这部超越中国电影水平50年的无厘头式作品，也有人说这是一部笑中带泪，总有一天你走在路上也会像一条狗的悲剧。
一千个人眼中有一千个哈姆雷特，对于一部影视作品，我们无法去评论任何一个人的理解是对还是错，因为经历不同，就像你不能把你的情感强加到别人身上。喜欢一部作品，在不知不觉间你会忽略他的缺点，讨厌一个事物，在不知不觉间就会放大他的短处。我们也不能用我们现代的思维和观念去评判20世纪港台电影的文化和情感。
至尊宝的路线是，有人给他点了三颗痣，拔出来紫青宝剑，开启了与紫霞的交涉，娶亲，戴上紧箍咒，大战牛魔王，西天取经。其实至尊宝这条路线，何尝不是我们的漫漫人生路呢，至尊宝用月光宝盒来寻找500年前的白晶晶，却阴差阳错遇到了紫霞仙子，最后在对白晶晶失而复得之后又得知紫霞在他内心留下的一滴眼泪，最终大彻大悟，明白了舍生取义，参透了生亦何哀，死亦何苦。我们的人生不也一样，总会有各种各样的未知因素影响我们的选择，在努力面对眼前一切之后，最终回头感叹年华，围炉小饮，本来无一物，何处惹尘埃。
对于紫霞和至尊宝的爱情，没有这种体验，是不会懂的，越是深情的人越容易受伤，她放下尊严来爱他，终于他后悔了。在至尊宝的梦里，紫霞仙子说：“飞蛾明明知道前面是火堆，却还义无反顾的扑进去。”她笑一下，接着说：“飞蛾就是这么傻！”而同样的至尊宝，“有一个名字叫紫霞的，你叫七百八十四次“，时光真是个好东西，所谓雕刻时光，是说生活像把钝刀，锉平我们的触觉，而电影则是解毒的重药，它让人突然领悟到，我们的内心要比自己想像的敏感干净得多！你等的那么辛苦，他却陌生到让你心疼。以至于在人生的不同阶段去欣赏《大话》，似乎都能从中找到某些影子，原先是笑，后来是苦，到最后便是沉默了。城墙上的一吻，至尊宝变成了旁观者，他借用夕阳武士的身份和转世的紫霞完成了他告别的深情，于是他的背影，他的离开，寂寞成了“好像一条狗”。
他好像一条狗呀！ -“那个人的样子好怪啊” -“我也看到了，他好像条狗啊” 是呀，英雄的离开，留下的永远只是背影，只不过在至尊宝这里加上了悲剧色彩，加上了人艰不拆的辛酸泪，以至于多少年后才明白了至尊宝转身离开有多难。至尊宝的结局是一个男人的悲怆与无奈。
至尊宝用了月光宝盒来寻找500年前的白晶晶，同时遇到了在她看来，他是她的命中注定的紫霞仙子，直到后来牛魔王的出现，夺走了紫霞，夺走了白晶晶，夺走了至尊宝往日的快乐，他明白他要夺回这一切，可是面对戏剧般的月光宝盒，至尊宝得到的更多是无力和苍白，面对这些无情的现实，幻想一次又一次地破灭。直到最后的关头，至尊宝终于醒悟，靠月光宝盒不行，至尊宝更是没有那个本事，只有成为孙悟空，只有戴上那个金刚圈，他才有能力同牛魔王一较高下。
这是一个极大的讽刺。你想要得到吗？好，那么你必须先放弃至尊宝的身份，你必须做出选择，必须忍受无尽的痛苦，他想要化解时间无尽的仇恨，就必须放弃自己的感情，不是不爱，而是大彻大悟之后的大爱，他必需化身为孙悟空，帮助唐三藏取得经书，化解这世间的恨。
那么至尊宝的放弃是自觉自愿的醒悟吗？不，他并不愿意，但是他必须拯救紫霞，必须化解人间的恨，他别无选择，他必须戴上紧箍咒。虽然成为了孙悟空，成了大英雄，但他对自己的生存状态极度不满。所以在最后，孙悟空将他心中残存的至尊宝的影子幻化作一位夕阳武士，在对现实世界彻底失望后，只能构造一个虚幻的想象来了却这桩心愿，并借武士的口中表达了对自己生存状态的不满，活得好象是一条狗一样。唉，一个男人的悲怆和无奈。
那句意中人，满足了多少人的少女心 “我知道有一天，他会在一个万众瞩目的情况下出现，身披金甲圣衣，脚踏七色云彩来娶我” “我的意中人是个盖世英雄，有一天他会踏着云彩来娶我” 这两句分别是紫霞在牛魔王娶她前的晚上和死前对孙悟空说的，多么经典的台词，以至于现在多少人还幻想着自己的意中人。
进入至尊宝内心的只有两个女人，一个是白晶晶，一个是紫霞，白晶晶问的是“他最喜欢的人是不是我”，紫霞问的是“他跟他的娘子是不是很恩爱呀？”，白晶晶的爱是一种索求的爱，而紫霞的爱则是无怨无悔的。
所以最终至尊宝回来了，在化身为孙悟空之后，身披金甲圣衣，脚踏七色云彩而来，他实现了紫霞的梦想，只不过加了一层掩饰与牵强。
从现如今这个角度反思紫霞的意中人，我是不太赞同的，童话毕竟是童话，正是这个经典的对白，让多少人活在自己的想象中，我们都渴望对方是个“意中人”的形象，可是我们却忽略乐一个”等价“的观念，你凭什么拥有你的”意中人“，你配得上吗？这不仅让我想起了另外一个命题：“不要去羡慕那些散发光芒的成功者，因为你不知道他背后付出的努力和艰辛”，这其实是一个道理，如果你仅仅是停留在幻想和计划的层面，那么你永远得不到你的”意中人“。
我猜中了开头，可是我猜不着这结局 紫霞说猜得到开始，却猜不透这结局。大约直到最后，她也没能明白、没能理解至尊宝的苦心。又或者说，是至尊宝从来也未能真正了解她的心意。我曾经以为，死去的紫霞是最可怜的角色。可是，至尊宝又何尝不可怜呢，他甚至，连伤心的权利也没有了。在紫霞死去的一瞬间，他的心也已经跟着死去了。在他余下的人生里，再也不会有欢笑、快乐，再也不会有那样一个可以在他心里流下眼泪的女孩子。就算取回西经又能如何，心爱的人再也会不来了。就算成佛又能如何，没有了你，整个世界对我来说都毫无意义。
《大话》把遗憾和难题抛给了时间 又一次的时空穿梭后，面对城头男女，孙悟空附身夕阳武士，给出无数人热泪纵横，内心中期盼的最后答案。 没有失去过，也永远不能明白得到的快乐。 附身后的孙悟空发自内心肺腑地给了女子一记深深长吻，这一吻穿越地老天荒，不再相信自欺欺人的一万年，他那般语气坚决地说出了那三个字。 先前拒不让步的夕阳武士，拥抱着爱人幸福陶醉。 转身远去的孙悟空了却尘缘心事，消失在大漠黄沙尽头。 只是每次在紫霞被刺中或者孙悟空松手的瞬间，还是会心潮如水甚至潸然泪下。 十年大话，一群人围坐着观看《大话西游》的狂热时代过去了，心底保存的泪水也慢慢尘封直至故事终结。毫无拘束的开怀大笑渐渐沦为一个人的狂欢，难加掩饰的心底苍凉逐渐成了人生重担
如今的你，何去何从 “如今的你，何去何从？” “对呀，何去何从”
真的羡慕至尊宝最初为了营救白晶晶，借用外力，使用月光宝盒穿越回500年前，为了解救紫霞，戴上紧箍咒。
而你呢？没有目标，你便是一个游荡的灵魂。
加长版加了什么 1：紫霞刚出现时在沙漠和雪蛤精，孔雀王的对话以及 他们的拔剑抢婚，与影片中紫霞和至尊宝在 牛魔王婚礼上遇见时雪蛤精，孔雀王和反对结婚作了呼应。
2：约好二更相见，原版是牛夫人出现 ，然后是至尊宝直接被猪八戒和沙师弟拉去救师父，加长版中先是牛夫人出现，然后牛魔王，然后至尊宝
3：牛魔王婚礼时猪八戒和沙僧在小妖堆里跟他们“打成一片”
4：至尊宝被青霞揍晕第二次之后，早上跟紫霞说的那通话“你要让我拿点信物给他看, 你有什么项链啊,首饰啊,金银珠宝啊,月光宝盒啊什么的……”原版的这段声音不是石班瑜所配。新版中，这段声音是重新配音，换上了石班瑜的声音。
5：2K画面的修复
一切的闹闹哄哄，只是他在水帘洞躲避风沙那晚做的一个梦
    </div>
  </div>
</div>

        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/thinkgamer/%E9%9A%8F%E6%89%8B%E8%AE%B0/%E5%88%AB%E4%BA%86%E9%9D%92%E6%98%A5%E4%B8%8E%E6%B5%81%E5%B9%B4%E9%81%87%E8%A7%81%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1/" class="link black dim">
        别了青春与流年，遇见下一个自己
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      如果说岁月是年轮，我们便是推行者，如果说成长是一场华丽的蜕变，我们便是领舞者。一路走来，太多不易，告别青春的年少轻狂，我们成了岁月里被磨平的棱角，静静的守在属于自己的一亩三分地。
 2016-时间是长了脚的妖怪，跑的飞快 &nbsp;&nbsp;&nbsp;&nbsp;四年时光，匆匆而过，沈阳占据了我23岁之前的太多第一次，第一次一个人一包行李，第一次21个小时的硬座，第一次坐地铁，第一次谈恋爱，第一次分手，第一次旅行，第一次坐摩天轮，第一次吃棉花糖，第一次看电影，第一次接触电脑，第一次&hellip;&hellip; &nbsp;&nbsp;&nbsp;&nbsp;时间是长了脚的妖怪，跑的飞快，只是好像后来我们都离开，各自生活在喧嚣未来，当时的遗憾在回忆肆虐的某些时段，重新打开，又好象我们同时都在。 &nbsp;&nbsp;&nbsp;&nbsp;有人说，谈过恋爱，分过手，挂过科，拿过奖学金，当过学生干部的大学才是完美的，那么我想我还是比较幸运的，回顾我的大学生活，除了两件我极力想做的事情没有完成之外，经历了太多，谈过恋爱，分过手，当过学生干部，拿过奖学金，参加过各种志愿活动，也做过校园代理，被坑过，被骗过，也干过兼职，做过外包，送过外卖，发过传单，在这整个过程中，认识了不少人，见过不少事，看明白了不少的社会道理，看清了多少人的虚情假意，感谢那一路让我经历成长的人。
&nbsp;&nbsp;&nbsp;&nbsp;大一是我大学生活里最快乐的一年，那时的我们很单纯。只是后来，大家都变了。
2016-剑未配好，已出江湖，来一场说走就走的北漂 &nbsp;&nbsp;&nbsp;&nbsp;该到来的还是会到来，虽然对于工作我是做好了准备，但是还是有点措手不及。
 七月，别了流年 &nbsp;&nbsp;&nbsp;&nbsp;那是七月，我的心情迫切的像火辣辣的太阳，拉着行李，从大学的门前离开，没有回头，虽然这里有我牵挂的人，有我念着的事，但我还是把更多的希望寄托在充满魔性的首都，因为我相信这里是梦会是开始的地方，于是在朋友的帮助下，我开启了我的北漂生活。
 广联达 &nbsp;&nbsp;&nbsp;&nbsp;我来北京的第一家公司是广联达，建筑行业国内算是龙头老大了，虽然在互联网行业不是太牛逼，但对于一个初出茅庐的我还是够我学习和经历了，而且凑巧的是公司是我一个八几年的校友创立的，只是这和我没有半毛钱关系，在那的三个月里，我连个人影都没有见过。 &nbsp;&nbsp;&nbsp;&nbsp;后来的后来我选择了离开，不是公司不好，不是带我的师父不优秀，不是同事不牛逼，只是我感觉那里不适合我。 &nbsp;&nbsp;&nbsp;&nbsp;我的师父是项目组组长吧，人有点娘娘腔，别人都叫他梅梅，但是对我们特别好，他技术也十分厉害，离开的时候和师父聊天，他说在公司是P3和P4的技术双认证，是一个技术架构师，自己带着团队几个月为公司写了一个云测试平台，现在更到3.x版本了吧。我个人是十分佩服我师父的，为人低调，技术够强，还有好人缘。 &nbsp;&nbsp;&nbsp;&nbsp;在公司的那段时候里，我主要做的是一个以课题形式展示的数据分析平台，用到的技术无非就是大学里学的那些，那个时候和另外一个同事还吹牛逼说咱也是架构师了，这仅仅是因为自己画了个水的一逼的图 &nbsp;&nbsp;&nbsp;&nbsp;哈哈，如果这幅图出自架构师之手，就是系统架构了，可是出自我们这等毛小子之手就是闹着玩了吧。就好比以国家的名义去挖墓，就是考古，以个人名义去挖墓就是盗墓了。
 昌平线，煎熬 &nbsp;&nbsp;&nbsp;&nbsp;西二旗是中国最堵得一个地铁站了，大家都说后村厂路堵车十分钟，中国互联网经济停滞2小时。 &nbsp;&nbsp;&nbsp;&nbsp;昌平线是北漂人的聚集地了，不是因为别的，是因为这条线路上的房租便宜 ，那个时候我就盘踞在沙河高教园旁边的东沙屯村里，每月800元的房租还是负担的起的，除了交通不便之外，一切还都可以接受，毕竟你是在北漂。
  2016-别了流年，是现在的我 &nbsp;&nbsp;&nbsp;&nbsp;九月末我面试了现在所在的公司，离开了广联达，不是因为它不优秀，它不好，只是因为那里现在还不适合我，在我的棱角被磨平之前，我想出去闯一闯。 &nbsp;&nbsp;&nbsp;&nbsp;可能是我所在部门的原因，我觉得特别懒散，感觉大家都是在混日子，每天改那么点bug，每天更新一点小功能，或者这就是大公司的尴尬，或者说转型之中的公司的短板吧，大家都沉浸在以前的辉煌之中，没有创造力，没有新奇的想法，没有交流的冲动，没有那种干劲。于是我选择了离开，我想先让我去经历一番我想要的工作与生活，等我累了，说不定我就会想念这种状态了。 &nbsp;&nbsp;&nbsp;&nbsp;现在所在的是一个创业公司，像我想象中一样，大家窝在一个不大的办公司，交流与合作，为了梦想一起努力着，很开心。 &nbsp;&nbsp;&nbsp;&nbsp;在这里我接触到了更多知识，技术的，做人的，交流的，至今我脑海中还清晰的记着那天赵总的一句话：读书要有收获，至少要涨气场。 &nbsp;&nbsp;&nbsp;&nbsp;新的环境里我接触学习了Docker，ELK，重新学习了一些机器学习的算法知识。于是在我的CSDN博客中创建了两个技术专栏，由于刚刚接触，写的也不够深入，不过我会努力的。 &nbsp;&nbsp;&nbsp;&nbsp;Docker江湖：http://blog.csdn.net/column/details/13159.html &nbsp;&nbsp;&nbsp;&nbsp;ELK从入门到放弃：http://blog.csdn.net/column/details/13079.html
&nbsp;&nbsp;&nbsp;&nbsp;认认真真经历才能好好成长。
2016-我在CSDN的收获  鲍大神 &nbsp;&nbsp;&nbsp;&nbsp;开始在CSDN上写博客是大一的时候，是一个牛逼的学长带我走上了这条&rdquo;不归路&rdquo;，谢谢鲍大神这一路的指导与传授，一直以来，他都是我的榜样。我也努力赶上他，只可惜看到的永远都是背影。
 梦姐姐 &nbsp;&nbsp;&nbsp;&nbsp;八月份的时候偶然的机会认识梦姐姐，做了博乐，后来也申请并通过了CSDN博客专家。
 结识技术爱好者 &nbsp;&nbsp;&nbsp;&nbsp;其实相比这些更重要的是通过CSDN所认识的每一个技术爱好者，可以说CSDN是国内的程序员的社交平台了。感觉那些给我留言提问我的人，可能有些疑问还是没有帮你们解决，只是我个人能力有限，不像郭神，鸿洋大神技术功底深厚。在这个平台之上，我也认识到了自己的许多不足和技术缺点，在阅读博客的过程中，也学到了不少东西。
  &nbsp;&nbsp;&nbsp;&nbsp;谢谢你一路陪我成长，你若不离，我定不弃。
2016-开始commit我的github &nbsp;&nbsp;&nbsp;&nbsp;有人说开源垃圾，有人说开源缩减了开发的成本和时间，不管怎样，开源是一种趋势，而且势头不会减弱，很荣幸我也投入了开源的大军，即使现在我还是一个蝼蚁。 &nbsp;&nbsp;&nbsp;&nbsp;我的github：https://github.com/thinkgamer 2016-杂乱无章 &nbsp;&nbsp;&nbsp;&nbsp;这一年，从一个初出茅庐的蝼蚁一步步成长，一个个经历，我给交了一份70分的答卷，我没有让我的父母和亲人失望，我没有让我的老师失望，我没有让我喜欢的人失望，我也没有让曾经看不起我的人失望，只是我让自己失望了。 &nbsp;&nbsp;&nbsp;&nbsp;有些东西我没有去争取，有些机会我没有把握，有些冲动我失了控。但正是这些完美的不完美的，才让你有更大的劲头去前进。
2017-下一个自己 &nbsp;&nbsp;&nbsp;&nbsp;时间不会因为你的遗憾而停留，我们能做的就是把每一天都当成最后一天来过。 &nbsp;&nbsp;&nbsp;&nbsp;2017，我要完成：
 一个安卓APP和对应的Web 小说《这夏未眠》 发表社区划分论文 深入学习Scala和Spark 掌握一个深度学习框架（eg：Caffe） 跟进研究Hadoop家族的最近版本，并形成文档 换一台Mackbook Pro 攒够100K+  &nbsp;&nbsp;&nbsp;&nbsp;感谢这一路有你，加油！
    </div>
  </div>
</div>

        
      
        <h2 class="f1">
          <a href="/chuxin/tags/%E9%9B%B7%E8%BE%BE" class="link blue hover-black">
            Tag: 雷达
          </a>
        </h2>
        
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2017-03-10-android%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%B7%E8%BE%BE%E6%89%AB%E6%8F%8F%E6%8E%A7%E4%BB%B6/" class="link black dim">
        Android自定义雷达扫描控件
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
Android 雷达扫描控件 
To get a Git project into your build:
Step 1. Add the JitPack repository to your build file
Add it in your root build.gradle at the end of repositories:
allprojects { repositories { ... maven { url 'https://jitpack.io' } } }  Step 2. Add the dependency
dependencies { compile 'com.github.kongqw:AndroidRadarScanView:1.0.1' }  源码：AndroidRadarScanView
效果图 XML &lt;com.kongqw.radarscanviewlibrary.RadarScanView android:id=&quot;@+id/radarScanView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt;  初始化 radarScanView = (RadarScanView) findViewById(R.
    </div>
  </div>
</div>

        
      
    </section>
  </div>

    </main>
    <footer class="bg-near-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://daonao.github.io/chuxin/" >
    &copy; 2018 不忘初心
  </a>
  








  </div>
</footer>

    <script src="https://daonao.github.io/chuxin/dist/app.bundle.js" async></script>

  </body>
</html>
