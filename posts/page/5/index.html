<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>不忘初心 </title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.30.2" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    <link href='https://daonao.github.io/chuxin/dist/main.css' rel='stylesheet' type="text/css" />
    
      
    

    
      <link href="https://daonao.github.io/chuxin/posts/index.xml" rel="alternate" type="application/rss+xml" title="不忘初心" />
      <link href="https://daonao.github.io/chuxin/posts/index.xml" rel="feed" type="application/rss+xml" title="不忘初心" />
    

    <meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://daonao.github.io/chuxin/posts/" />



<meta property="og:updated_time" content="2016-09-01T17:37:11&#43;00:00"/>










<meta itemprop="name" content="Posts">
<meta itemprop="description" content="">

<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>

  </head>

  <body class="ma0 avenir bg-near-white">

    

  
  
  <header class="cover bg-top" style="background-image: url('https://daonao.github.io/chuxin/images/gohugo-default-sample-hero-image.jpg');">
    <div class="bg-black-60">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://daonao.github.io/chuxin/" class="f3 fw2 hover-white no-underline white-90 dib">
      不忘初心
    </a>
    <div class="flex-l items-center">
      
      








    </div>
  </div>
</nav>

      <div class="tc-l pv4 pv6-l ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 white-90 mb0 lh-title">
          Posts
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
  <article class="cf pa3 pa4-m pa4-l">
    <div class="measure-wide-l center f4 lh-copy nested-copy-line-height nested-links nested-img mid-gray">
      
    </div>
  </article>
  <div class="mw8 center">
    
    <section class="flex-ns flex-wrap justify-around mt5">
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-09-01-android%E8%87%AA%E5%AE%9A%E4%B9%89%E6%91%87%E6%9D%86/" class="link black dim">
        Android自定义摇杆
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
效果图 源码 KqwRockerDemo
喜欢就给个star，谢谢！
功能  支持自适应大小 支持2个方向、4个方向、8个方向的摇动监听 支持摇动角度获取 可选回调模式 支持可摇动区域自定义 支持摇杆自定义 支持设置图片、色值、Shape图形  使用 &lt;kong.qingwei.rockerlibrary.RockerView android:id=&quot;@+id/rockerView_center&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:layout_centerHorizontal=&quot;true&quot; kongqw:areaBackground=&quot;#FF333333&quot; kongqw:rockerBackground=&quot;#FF987654&quot; kongqw:rockerRadius=&quot;15dp&quot; /&gt;  参数    参数 是否必须 描述     areaBackground 可选 可摇动区域的背景   rockerBackground 可选 摇杆的背景   rockerRadius 可选 摇杆半径    设置回调方式 setCallBackMode(CallBackMode mode)  参数
   回调方式 描述     CALL_BACK_MODE_MOVE 有移动就立刻回调   CALL_BACK_MODE_STATE_CHANGE 状态有变化的时候回调    监听摇动角度 返回角度的取值范围：[0°,360°)
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-29-android%E8%BE%93%E5%87%BA%E6%AD%A3%E5%BC%A6%E6%B3%A2%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7-%E5%B7%A6%E5%8F%B3%E5%A3%B0%E9%81%93%E5%AF%B9%E7%A7%B0/" class="link black dim">
        Android输出正弦波音频信号(左右声道对称)
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
需求：左右声道分别输出不同的音频数据，波形要是一个正弦波，左右声道还要对称！ 对硬件不是很了解，说是要通过音波避障。
效果图 之前已经介绍了如何在左右声道输出不同的音频数据。 那么这里主要介绍如何模拟出波形是正弦波的音频数据。
模拟正弦波 /** * 模拟正弦波音频数据 * @param isLeft 左右声道 * @return 音频数据 */ private short[] initData(boolean isLeft) { double phase = 0.0; int amp = 10000; short[] data = new short[bufferSize]; double phaseIncrement = (2 * Math.PI * mFrequency) / mSampleRateInHz; for (int i = 0; i &lt; bufferSize; i++) { if (isLeft) { data[i] = (short) (amp * Math.sin(phase)); } else { data[i] = (short) (-amp * Math.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-26-android%E5%B7%A6%E5%8F%B3%E5%A3%B0%E9%81%93%E7%9A%84%E6%8E%A7%E5%88%B6/" class="link black dim">
        Android左右声道的控制
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
效果图 源码 AndroidSoundManagerDemo
我这里主要是用到了AudioTrack实现的左右声道的控制，手机一般都只有两个声道，即左声道和右声道，我们在输出的时候可以选择单声道，也可以选择双声道（立体声）。
查看了AudioTrack的API，提供了play()、pause()、stop()、write()等一系列的方法。 通过write()方法，可以实现将音频数据发送出去（播放出来）。
AudioTrack对象的构造 有三个构造方法
AudioTrack (int streamType, int sampleRateInHz, int channelConfig, int audioFormat, int bufferSizeInBytes, int mode) AudioTrack (int streamType, int sampleRateInHz, int channelConfig, int audioFormat, int bufferSizeInBytes, int mode, int sessionId) AudioTrack (AudioAttributes attributes, AudioFormat format, int bufferSizeInBytes, int mode, int sessionId)  主要参数有如下几个
 streamType：以什么形式播放
 STREAM_VOICE_CALL STREAM_SYSTEM STREAM_RING STREAM_MUSIC STREAM_ALARM STREAM_NOTIFICATION  sampleRateInHz：采样率
 channelConfig：声道
 AudioFormat.CHANNEL_OUT_MONO：输出单声道音频数据 AudioFormat.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-22-%E7%8E%AF%E4%BF%A1%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E5%9C%A8android%E5%B9%B3%E5%8F%B0%E7%9A%84%E9%83%A8%E7%BD%B2/" class="link black dim">
        环信即时通讯在Android平台的部署
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
官网 环信
下载SDK
创建一个工程 如果想要封装性好一点，也可以在工程里再创建一个环信的Library，然后将SDK里的jar和.so，都导入到工程
清单文件 下面是环信Library库里面的清单文件，包含了权限的设置、APPKEY的设置和服务的声明等。
&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;……&quot;&gt; &lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.GET_TASKS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.USE_CREDENTIALS&quot; /&gt; &lt;uses-permission android:name=&quot;com.android.launcher.permission.READ_SETTINGS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.BROADCAST_STICKY&quot; /&gt; &lt;uses-permission android:name=&quot;android.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-22-opencv%E6%A3%80%E6%B5%8B%E5%9B%BE%E5%83%8F%E8%BD%AE%E5%BB%93/" class="link black dim">
        OpenCV检测图像轮廓
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
轮廓只不过是图像中连接的曲线，或者图像中连通部分的边界，轮廓通常以图像中的边缘来计算，但是，边缘和轮廓的区别在于轮廓是闭合的，而边缘可以是任意的。边缘的概念局限于点及其邻域像素，轮廓将目标作为整体进行处理。
效果图 源码 KqwOpenCVFeaturesDemo
步骤  将图像置灰 使用Canny边缘检测检测出图像的边缘 调用Imgproc.findContours()方法检测图像轮廓 在新的图像上画出轮廓  封装 /** * 找出轮廓 * * @param bitmap 要检测的图片 */ public void findContours(Bitmap bitmap) { if (null != mSubscriber) Observable .just(bitmap) // 检测边缘 .map(new Func1&lt;Bitmap, Mat&gt;() { @Override public Mat call(Bitmap bitmap) { Mat grayMat = new Mat(); Mat cannyEdges = new Mat(); // Bitmap转为Mat Mat src = new Mat(bitmap.getHeight(), bitmap.getWidth(), CvType.CV_8UC4); Utils.bitmapToMat(bitmap, src); // 原图置灰 Imgproc.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-22-opencv%E4%BD%BF%E7%94%A8%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E6%A3%80%E6%B5%8B%E5%9B%BE%E5%83%8F%E4%B8%AD%E7%9A%84%E5%BD%A2%E7%8A%B6/" class="link black dim">
        OpenCV使用霍夫变换检测图像中的形状
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
霍夫变换是一种被广泛使用的利用数学等式的参数形式在图像中检测形状的技术。 例如直线、椭圆、圆等形状。
霍夫变换可以检测任何能以参数形式表示的形状，随着形状的复杂（维数的增加，例如球体），计算的消耗也会增加。 我们通常只考虑简单的霍夫形状，例如直线和圆。
源码 KqwOpenCVFeaturesDemo
霍夫直线 效果图 步骤  将图像置灰 调用Imgproc.HoughLinesP(cannyEdges, lines, 1, Math.PI / 180, 50, 20, 20) 方法获取直线的数据
 第一个参数：图像输入 第二个参数：图像输出 第三个参数：图像指定像素中r的解析度 第四个参数：图像指定像素中θ的解析度 第五个参数：直线上点数的阈值 第六个参数：直线上点数的最小值  在图像上绘制直线
  封装 /** * 霍夫直线 * * @param bitmap 要检测的图片 */ public void houghLines(Bitmap bitmap) { if (null != mSubscriber) Observable .just(bitmap) // 检测边缘 .map(new Func1&lt;Bitmap, Mat&gt;() { @Override public Mat call(Bitmap bitmap) { Mat grayMat = new Mat(); Mat cannyEdges = new Mat(); // Bitmap转为Mat Mat src = new Mat(bitmap.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-19-opencv%E4%BD%BF%E7%94%A8harris%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E8%A7%92%E7%82%B9%E6%A3%80%E6%B5%8B/" class="link black dim">
        OpenCV使用Harris算法实现角点检测
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
效果图 源码 KqwOpenCVFeaturesDemo
角点是两条边缘的交点或者在局部邻域中有多个显著边缘方向的点。Harris角点检测是一种在角点检测中最常见的技术。
Harris角点检测器在图像上使用滑动窗口计算亮度的变化。
封装 这里用到了RxJava。主要是因为图片处理是耗时操作，会阻塞线程，为了防止界面卡顿，这里使用RxJava进行了线程切换。
/** * Harris角点检测 * * @param bitmap 要检测的图片 */ public void harris(Bitmap bitmap) { if (null != mSubscriber) Observable .just(bitmap) // 检测边缘 .map(new Func1&lt;Bitmap, Mat&gt;() { @Override public Mat call(Bitmap bitmap) { Mat grayMat = new Mat(); Mat cannyEdges = new Mat(); // Bitmap转为Mat Mat src = new Mat(bitmap.getHeight(), bitmap.getWidth(), CvType.CV_8UC4); Utils.bitmapToMat(bitmap, src); // 原图置灰 Imgproc.cvtColor(src, grayMat, Imgproc.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-19-opencv%E4%BD%BF%E7%94%A8sobel%E6%BB%A4%E6%B3%A2%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/" class="link black dim">
        OpenCV使用Sobel滤波器实现图像边缘检测
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
效果图 源码 KqwOpenCVFeaturesDemo
Sobel滤波器也叫Sobel算子，与Canny边缘检测一样，需要计算像素的灰度梯度，只不过是换用另一种方式。
使用Sobel算子计算边缘的步骤  将图像转为灰度图像
// 原图置灰 Imgproc.cvtColor(src, grayMat, Imgproc.COLOR_BGR2GRAY);  计算水平方向灰度梯度的绝对值
Imgproc.Sobel(grayMat, grad_x, CvType.CV_16S, 1, 0, 3, 1, 0); Core.convertScaleAbs(grad_x, abs_grad_x);  计算垂直方法灰度梯度的绝对值
Imgproc.Sobel(grayMat, grad_y, CvType.CV_16S, 0, 1, 3, 1, 0); Core.convertScaleAbs(grad_y, abs_grad_y);  计算最终梯度
// 计算结果梯度 Core.addWeighted(abs_grad_x, 0.5, abs_grad_y, 0.5, 1, sobel);   最终的梯度实质上就是边缘。
这里用到了两个3 * 3的核对图像做卷积来近似地计算水平和垂直方向的灰度梯度
封装 这里用到了RxJava。主要是因为图片处理是耗时操作，会阻塞线程，为了防止界面卡顿，这里使用RxJava进行了线程切换。
/** * Sobel滤波器 * * @param bitmap 要检测的图片 */ public void sobel(Bitmap bitmap) { if (null !
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-19-opencv%E4%BD%BF%E7%94%A8canny%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/" class="link black dim">
        OpenCV使用Canny边缘检测器实现图像边缘检测
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
效果图 源码 KqwOpenCVFeaturesDemo
Canny边缘检测器是一种被广泛使用的算法，并被认为是边缘检测最优的算法，该方法使用了比高斯差分算法更复杂的技巧，如多向灰度梯度和滞后阈值化。
Canny边缘检测器算法基本步骤  平滑图像：通过使用合适的模糊半径执行高斯模糊来减少图像内的噪声。 计算图像的梯度：这里计算图像的梯度，并将梯度分类为垂直、水平和斜对角。这一步的输出用于在下一步中计算真正的边缘。 非最大值抑制：利用上一步计算出来的梯度方向，检测某一像素在梯度的正方向和负方向上是否是局部最大值，如果是，则抑制该像素（像素不属于边缘）。这是一种边缘细化技术，用最急剧的变换选出边缘点。 用滞后阈值化选择边缘：最后一步，检查某一条边缘是否明显到足以作为最终输出，最后去除所有不明显的边缘。  算法比较复杂，但是使用很简单，首先将图像灰度化
// 原图置灰 Imgproc.cvtColor(src, grayMat, Imgproc.COLOR_BGR2GRAY);  然后调用Imgproc.Canny()方法即可
// Canny边缘检测器检测图像边缘 Imgproc.Canny(grayMat, cannyEdges, 10, 100);   第一个参数表示图像输入 第二个参数表述图像输出 第三个参数表示低阈值 第四个参数表示高阈值  在Canny边缘检测算法中，将图像中的点归为三类：
 被抑制点
灰度梯度值 &lt; 低阈值
 弱边缘点
低阈值 &lt;= 灰度梯度值 &lt;= 高阈值
 强边缘点
高阈值 &lt; 灰度梯度值
  封装 这里用到了RxJava。主要是因为图片处理是耗时操作，会阻塞线程，为了防止界面卡顿，这里使用RxJava进行了线程切换。
/** * Canny边缘检测算法 * * @param bitmap 要检测的图片 */ public void canny(Bitmap bitmap) { if (null !
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/chuxin/posts/kongqw/2016-08-19-opencv%E9%AB%98%E6%96%AF%E5%B7%AE%E5%88%86%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/" class="link black dim">
        OpenCV高斯差分技术实现图像边缘检测
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      转载请说明出处！ 作者：kqw攻城狮 出处：个人站 | CSDN
效果图 源码 KqwOpenCVFeaturesDemo
边缘是图像中像素亮度变化明显的点。
高斯差分算法步骤  将图像转为灰度图像
// 原图置灰 Imgproc.cvtColor(src, grayMat, Imgproc.COLOR_BGR2GRAY);  用两个不同的模糊半径对灰度图像执行高斯模糊（取得两幅高斯模糊图像）
// 以两个不同的模糊半径对图像做模糊处理 Imgproc.GaussianBlur(grayMat, blur1, new Size(15, 15), 5); Imgproc.GaussianBlur(grayMat, blur2, new Size(21, 21), 5);  将两幅高斯模糊图像做减法，得到一幅包含边缘点的结果图像
// 将两幅模糊后的图像相减 Mat diff = new Mat(); Core.absdiff(blur1, blur2, diff);   该方法只对图像做了高斯模糊，这是计算图像边缘最快的方法之一，但是，该方法的结果也不是很理想，这种方式对某些图像效果很好，但是在某些情况下可能会完全失效。
封装 这里用到了RxJava。主要是因为图片处理是耗时操作，会阻塞线程，为了防止界面卡顿，这里使用RxJava进行了线程切换。
/** * 高斯差分算法边缘检测 * * @param bitmap 要检测的图片 */ public void differenceOfGaussian(Bitmap bitmap) { if (null != mSubscriber) Observable .
    </div>
  </div>
</div>

        </div>
      
    </section>
  

<ul class="pagination">
    
    <li>
        <a href="/chuxin/posts/" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
    </li>
    
    <li
    >
    <a href="/chuxin/posts/page/4/" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
    </li>
    
    
    
    
    
    
        
        
    
    
    <li
    ><a href="/chuxin/posts/">1</a></li>
    
    
    
    
    
    
        
        
    
    
    <li
    ><a href="/chuxin/posts/page/2/">2</a></li>
    
    
    
    
    
    
        
        
    
    
    <li
    ><a href="/chuxin/posts/page/3/">3</a></li>
    
    
    
    
    
    
        
        
    
    
    <li
    ><a href="/chuxin/posts/page/4/">4</a></li>
    
    
    
    
    
    
        
        
    
    
    <li
    class="active"><a href="/chuxin/posts/page/5/">5</a></li>
    
    
    
    
    
    
        
        
    
    
    <li
    ><a href="/chuxin/posts/page/6/">6</a></li>
    
    
    
    
    
    
        
        
    
    
    <li class="disabled"><span aria-hidden="true">&hellip;</span></li>
    
    
    
    
    
    
        
        
    
    
    <li
    ><a href="/chuxin/posts/page/8/">8</a></li>
    
    
    <li
    >
    <a href="/chuxin/posts/page/6/" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
    </li>
    
    <li>
        <a href="/chuxin/posts/page/8/" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
    </li>
    
</ul>

  </div>

    </main>
    <footer class="bg-near-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://daonao.github.io/chuxin/" >
    &copy; 2018 不忘初心
  </a>
  








  </div>
</footer>

    <script src="https://daonao.github.io/chuxin/dist/app.bundle.js" async></script>

  </body>
</html>
